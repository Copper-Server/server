#include <filesystem>
#include <fstream>
#include <iostream>

struct resource_location {
    std::string namespace_open;
    std::string name;
    std::string namespace_close;
    std::string full_name;
    std::filesystem::path output_path;
};

resource_location resource_location_extractor(const char* parent_namespace, const std::filesystem::path& path, const char* output_path_parent) {
    resource_location location;
    location.output_path = output_path_parent;


    location.name = path.stem().string();
    if (!isalpha(location.name[0]) && location.name[0] != '_')
        location.name = "_" + location.name;

    auto parent_path = path.parent_path();
    std::vector<std::string> namespaces;
    while (parent_path != parent_path.root_path() && parent_path.filename().string() != "resources") {
        namespaces.push_back(parent_path.filename().string());
        parent_path = parent_path.parent_path();
    }
    namespaces.push_back("resources");
    namespaces.push_back(parent_namespace);
    std::reverse(namespaces.begin(), namespaces.end());

    size_t spaces = 0;
    for (auto& ns : namespaces)
        location.output_path /= ns;
    location.output_path /= location.name;

    for (auto& ns : namespaces) {
        location.namespace_open += std::string(spaces, ' ') + "namespace " + ns + " {\n";
        spaces += 4;
        location.full_name += ns + "::";
    }
    location.namespace_open += std::string(spaces, ' ');

    for (auto& ns : namespaces) {
        spaces -= 4;
        location.namespace_close += std::string(spaces, ' ') + "};\n";
    }


    location.full_name += location.name;
    return location;
}

int direct_resource(const resource_location& location, const std::filesystem::path& input_file) {

    std::filesystem::path output_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".cpp");
    std::filesystem::path header_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".hpp");

    auto file_change_time = std::filesystem::last_write_time(input_file);

    std::filesystem::create_directories(output_file.parent_path());

    if (std::filesystem::exists(output_file) && std::filesystem::exists(header_file)) {
        auto output_file_time = std::filesystem::last_write_time(output_file);
        auto header_file_time = std::filesystem::last_write_time(header_file);
        if (file_change_time < output_file_time && file_change_time < header_file_time)
            return 0;
    }

    std::cout << "Building resource: " << location.full_name << std::endl;

    std::ifstream in(input_file, std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << input_file << "\n";
        return 1;
    }

    std::ofstream out(output_file, std::ios::binary);
    if (!out) {
        std::cerr << "Error opening output file: " << output_file << "\n";
        return 1;
    }

    std::ofstream header(header_file, std::ios::binary);
    if (!header) {
        std::cerr << "Error opening header file: " << header_file << "\n";
        return 1;
    }

    out << "//!Autogenerated file, do not modify\n"
           "#include \""
        << location.output_path.filename().string() + ".hpp\"\n";
    out << location.namespace_open
        << "const char __" << location.name << "[] = {";
    unsigned char c;
    while (in.get(reinterpret_cast<char&>(c)))
        out << "0x" << std::hex << static_cast<int>(c) << ", ";
    out << "};\n";

    out << "const std::string_view " << location.name << "(__" << location.name << ", sizeof(__" << location.name << "));\n";
    out << location.namespace_close;


    header << "//!Autogenerated file, do not modify\n";
    header << "#pragma once\n#include <string>\n";
    header << location.namespace_open
           << "extern const std::string_view " << location.name << ";\n";
    header << location.namespace_close;

    std::cout << "Resource built successfully: " << location.full_name << std::endl;

    return 0;
}

int ___recursive_merge_json(std::ofstream& out, const std::filesystem::directory_entry& file);

int ___recursive_merge_json__file(std::ofstream& out, const std::filesystem::directory_entry& file) {
    std::ifstream in(file.path(), std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << file.path() << "\n";
        return 1;
    }
    unsigned char c;
    while (in.get(reinterpret_cast<char&>(c)))
        out << c;
    return 0;
}

int ___recursive_merge_json__directory(std::ofstream& out, const std::filesystem::directory_entry& file) {
    out << "{";
    bool begin = true;
    for (const auto& f : std::filesystem::directory_iterator(file.path())) {
        if (!begin)
            out << ", ";
        begin = false;
        if (auto it = ___recursive_merge_json(out, f); it != 0) {
            if (it == 2)
                continue;
            return it;
        }
    }
    out << "}";
    return 0;
}

int ___recursive_merge_json(std::ofstream& out, const std::filesystem::directory_entry& file) {
    std::string key = file.path().filename().string();
    out << "\"" << key << "\": ";
    if (file.is_directory())
        return ___recursive_merge_json__directory(out, file);
    else
        return ___recursive_merge_json__file(out, file);
    return 0;
}

//int ___recursive_merge_json(std::ofstream& out, const std::filesystem::path& file) {
//    for (const auto& f : std::filesystem::directory_iterator(file))
//        if (auto it = ___recursive_merge_json(out, f); it != 0)
//            return it;
//    return 0;
//}
//int ___recursive_merge_json(std::ofstream& out, const std::filesystem::directory_entry& file);
//
//int ___recursive_merge_json__file(std::ofstream& out, const std::filesystem::directory_entry& file) {
//    constexpr int key_delim = ':';
//    constexpr int key_scope = '"';
//
//    std::ifstream in(file.path(), std::ios::binary);
//    if (!in) {
//        std::cerr << "Error opening input file: " << file.path() << "\n";
//        return 1;
//    }
//    std::string key = file.path().filename().string();
//
//    out << "0x" << std::hex << key_scope;
//    for (auto& c : key)
//        out << ", 0x" << std::hex << static_cast<int>(c);
//    out << ", 0x" << std::hex << key_scope << ", 0x" << std::hex << key_delim << ", ";
//    unsigned char c;
//    while (in.get(reinterpret_cast<char&>(c)))
//        out << "0x" << std::hex << static_cast<int>(c) << ", ";
//    return 0;
//}
//
//int ___recursive_merge_json__directory(std::ofstream& out, const std::filesystem::directory_entry& file) {
//    constexpr int scope_begin = '{';
//    constexpr int scope_end = '}';
//    constexpr int key_delim = ':';
//    constexpr int key_scope = '"';
//    constexpr int scope_comma = ',';
//    std::string key = file.path().filename().string();
//
//    out << "0x" << std::hex << scope_begin << ", 0x" << std::hex << key_scope;
//    for (auto& c : key)
//        out << ", 0x" << std::hex << static_cast<int>(c);
//    out << ", 0x" << std::hex << key_scope << ", 0x" << std::hex << key_delim << ", 0x" << std::hex << scope_begin << ", ";
//
//
//    for (const auto& f : std::filesystem::directory_iterator(file.path())) {
//        if (auto it = ___recursive_merge_json(out, f); it != 0) {
//            if (it == 2)
//                continue;
//            return it;
//        }
//        out << "0x" << std::hex << scope_comma << ", ";
//    }
//
//    out << "0x" << std::hex << scope_end << ", ";
//    return 0;
//}
//
//int ___recursive_merge_json(std::ofstream& out, const std::filesystem::directory_entry& file) {
//    if (file.is_directory())
//        return ___recursive_merge_json__directory(out, file);
//    else
//        return ___recursive_merge_json__file(out, file);
//    return 0;
//}
//


int ___recursive_merge_json(std::ofstream& out, const std::filesystem::path& file) {
    out << "{";
    bool begin = true;
    for (const auto& f : std::filesystem::directory_iterator(file)) {
        if (!begin)
            out << ", ";
        begin = false;
        if (auto it = ___recursive_merge_json(out, f); it != 0)
            return it;
    }
    out << "}";
    return 0;
}

int merge_json_resource(const resource_location& location, const std::filesystem::path& input_file) {
    std::filesystem::path tmp_file = location.output_path.parent_path() / (location.output_path.filename().string() + "_tmp.json");
    std::filesystem::path output_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".cpp");
    std::filesystem::path header_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".hpp");

    auto file_change_time = std::filesystem::last_write_time(input_file);

    std::filesystem::create_directories(output_file.parent_path());

    if (std::filesystem::exists(output_file) && std::filesystem::exists(header_file)) {
        auto output_file_time = std::filesystem::last_write_time(output_file);
        auto header_file_time = std::filesystem::last_write_time(header_file);
        if (file_change_time < output_file_time && file_change_time < header_file_time)
            return 0;
    }

    {
        std::ofstream out(tmp_file, std::ios::binary | std::ios::trunc);
        if (!out) {
            std::cerr << "Error opening output file: " << tmp_file << "\n";
            return 1;
        }

        if (auto it = ___recursive_merge_json(out, input_file); it != 0)
            return it;
    }

    std::cout << "Building resource: " << location.full_name << std::endl;

    std::ifstream in(tmp_file, std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << tmp_file << "\n";
        return 1;
    }

    std::ofstream out(output_file, std::ios::binary);
    if (!out) {
        std::cerr << "Error opening output file: " << output_file << "\n";
        return 1;
    }

    std::ofstream header(header_file, std::ios::binary);
    if (!header) {
        std::cerr << "Error opening header file: " << header_file << "\n";
        return 1;
    }

    out << "//!Autogenerated file, do not modify\n"
           "#include \""
        << location.output_path.filename().string() + ".hpp\"\n";
    out << location.namespace_open
        << "const char __" << location.name << "[] = {";
    unsigned char c;
    while (in.get(reinterpret_cast<char&>(c)))
        out << "0x" << std::hex << static_cast<int>(c) << ", ";
    out << "};\n";

    out << "const std::string_view " << location.name << "(__" << location.name << ", sizeof(__" << location.name << "));\n";
    out << location.namespace_close;


    header << "//!Autogenerated file, do not modify\n";
    header << "#pragma once\n#include <string>\n";
    header << location.namespace_open
           << "extern const std::string_view " << location.name << ";\n";
    header << location.namespace_close;

    std::cout << "Resource built successfully: " << location.full_name << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc != 5) {
        std::cerr << "Usage: " << argv[0] << " <direct/merge_json> <project namespace> <input resource> <base_output_path>\n";
        return 1;
    }

    std::filesystem::path input_file = argv[3];
    resource_location location = resource_location_extractor(argv[2], input_file, argv[4]);

    if (strcmp(argv[1], "direct") == 0)
        return direct_resource(location, input_file);
    else if (strcmp(argv[1], "merge_json") == 0)
        return merge_json_resource(location, input_file);
    else {
        std::cerr << "Unknown command: " << argv[1] << "\n";
        return 1;
    }

    return 0;
}