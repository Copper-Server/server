#include <filesystem>
#include <fstream>
#include <iostream>

struct resource_location {
    std::string namespace_open;
    std::string name;
    std::string namespace_close;
    std::string full_name;
    std::filesystem::path output_path;
};

resource_location resource_location_extractor(const char* parent_namespace, const std::filesystem::path& path, const char* output_path_parent) {
    resource_location location;
    location.output_path = output_path_parent;


    location.name = path.stem().string();
    if (!isalpha(location.name[0]) && location.name[0] != '_')
        location.name = "_" + location.name;

    auto parent_path = path.parent_path();
    std::vector<std::string> namespaces;
    while (parent_path != parent_path.root_path() && parent_path.filename().string() != "resources") {
        namespaces.push_back(parent_path.filename().string());
        parent_path = parent_path.parent_path();
    }
    namespaces.push_back("resources");
    namespaces.push_back(parent_namespace);
    std::reverse(namespaces.begin(), namespaces.end());

    size_t spaces = 0;
    for (auto& ns : namespaces)
        location.output_path /= ns;
    location.output_path /= location.name;

    for (auto& ns : namespaces) {
        location.namespace_open += std::string(spaces, ' ') + "namespace " + ns + " {\n";
        spaces += 4;
        location.full_name += ns + "::";
    }
    location.namespace_open += std::string(spaces, ' ');

    for (auto& ns : namespaces) {
        spaces -= 4;
        location.namespace_close += std::string(spaces, ' ') + "};\n";
    }


    location.full_name += location.name;
    return location;
}

int main(int argc, char* argv[]) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <project namespace> <input resource> <base_output_path>\n";
        return 1;
    }

    std::filesystem::path input_file = argv[2];
    resource_location location = resource_location_extractor(argv[1], input_file, argv[3]);

    std::filesystem::path output_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".cpp");
    std::filesystem::path header_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".hpp");

    auto file_size = std::filesystem::file_size(input_file);
    auto file_change_time = std::filesystem::last_write_time(input_file);

    std::filesystem::create_directories(output_file.parent_path());

    if (std::filesystem::exists(output_file) && std::filesystem::exists(header_file)) {
        auto output_file_time = std::filesystem::last_write_time(output_file);
        auto header_file_time = std::filesystem::last_write_time(header_file);
        if (file_change_time < output_file_time && file_change_time < header_file_time)
            return 0;
    }

    std::cout << "Building resource: " << location.full_name << std::endl;

    std::ifstream in(input_file, std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << input_file << "\n";
        return 1;
    }

    std::ofstream out(output_file, std::ios::binary);
    if (!out) {
        std::cerr << "Error opening output file: " << output_file << "\n";
        return 1;
    }

    std::ofstream header(header_file, std::ios::binary);
    if (!header) {
        std::cerr << "Error opening header file: " << header_file << "\n";
        return 1;
    }

    out << "//!Autogenerated file, do not modify\n"
           "#include \""
        << location.output_path.filename().string() + ".hpp\"\n";
    out << location.namespace_open
        << "const std::array<uint8_t, " << file_size << "> " << location.name << " = {";
    unsigned char c;
    while (in.get(reinterpret_cast<char&>(c)))
        out << "0x" << std::hex << static_cast<int>(c) << ", ";
    out << "};\n";
    out << location.namespace_close;


    header << "//!Autogenerated file, do not modify\n";
    header << "#pragma once\n\n";
    header << "#include<array>\n";
    header << "#include<cstdint>\n";
    header << location.namespace_open
           << "extern const std::array<uint8_t,  " << file_size << "> " << location.name << ";\n";
    header << location.namespace_close;

    std::cout << "Resource built successfully: " << location.full_name << std::endl;
    return 0;
}