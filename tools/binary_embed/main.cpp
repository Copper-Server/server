#include "../../library/enbt/io_tools.hpp"
#include "../../library/enbt/senbt.hpp"
#include <boost/iostreams/filter/zstd.hpp>
#include <boost/iostreams/filtering_stream.hpp>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stacktrace>

struct resource_location {
    std::string namespace_open;
    std::string name;
    std::string namespace_close;
    std::string full_name;
    std::filesystem::path output_path;
};

resource_location resource_location_extractor(const char* parent_namespace, const std::filesystem::path& path, const char* output_path_parent) {
    resource_location location;
    location.output_path = output_path_parent;


    location.name = path.stem().string();
    if (!isalpha(location.name[0]) && location.name[0] != '_')
        location.name = "_" + location.name;

    auto parent_path = path.parent_path();
    std::vector<std::string> namespaces;
    while (parent_path != parent_path.root_path() && parent_path.filename().string() != "resources") {
        namespaces.push_back(parent_path.filename().string());
        parent_path = parent_path.parent_path();
    }
    namespaces.push_back("resources");
    namespaces.push_back(parent_namespace);
    std::reverse(namespaces.begin(), namespaces.end());

    size_t spaces = 0;
    for (auto& ns : namespaces)
        location.output_path /= ns;
    location.output_path /= location.name;

    for (auto& ns : namespaces) {
        location.namespace_open += std::string(spaces, ' ') + "namespace " + ns + " {\n";
        spaces += 4;
        location.full_name += ns + "::";
    }
    location.namespace_open += std::string(spaces, ' ');

    for (auto& ns : namespaces) {
        spaces -= 4;
        location.namespace_close += std::string(spaces, ' ') + "};\n";
    }


    location.full_name += location.name;
    return location;
}

int direct_resource(const resource_location& location, const std::filesystem::path& input_file, bool skip_empty = false) {

    std::filesystem::path output_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".cpp");
    std::filesystem::path header_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".hpp");

    auto file_change_time = std::filesystem::last_write_time(input_file);

    std::filesystem::create_directories(output_file.parent_path());

    if (std::filesystem::exists(output_file) && std::filesystem::exists(header_file)) {
        auto output_file_time = std::filesystem::last_write_time(output_file);
        auto header_file_time = std::filesystem::last_write_time(header_file);
        if (file_change_time < output_file_time && file_change_time < header_file_time)
            return 0;
    }

    std::cout << "Building resource: " << location.full_name << std::endl;

    std::ifstream in(input_file, std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << input_file << "\n";
        return 1;
    }

    std::ofstream out(output_file, std::ios::binary);
    if (!out) {
        std::cerr << "Error opening output file: " << output_file << "\n";
        return 1;
    }

    std::ofstream header(header_file, std::ios::binary);
    if (!header) {
        std::cerr << "Error opening header file: " << header_file << "\n";
        return 1;
    }

    out << "//!Autogenerated file, do not modify\n"
           "#include \""
        << location.output_path.filename().string() + ".hpp\"\n";
    out << location.namespace_open
        << "const unsigned char __" << location.name << "[] = {";
    unsigned char c;
    if (skip_empty) {
        while (in.get(reinterpret_cast<char&>(c))) {
            if (c == ' ' || c == '\r' || c == '\n' || c == '\t')
                continue;
            out << "0x" << std::hex << static_cast<int>((uint8_t)c) << ", ";
        }
    } else
        while (in.get(reinterpret_cast<char&>(c)))
            out << "0x" << std::hex << static_cast<int>((uint8_t)c) << ", ";
    out << "};\n";

    out << "const std::string_view " << location.name << "((char*)__" << location.name << ", sizeof(__" << location.name << "));\n";
    out << location.namespace_close;


    header << "//!Autogenerated file, do not modify\n";
    header << "#pragma once\n#include <string>\n";
    header << location.namespace_open
           << "extern const std::string_view " << location.name << ";\n";
    header << location.namespace_close;

    std::cout << "Resource built successfully: " << location.full_name << std::endl;

    return 0;
}

int ___recursive_merge_json(std::ofstream& out, const std::filesystem::directory_entry& file);

int ___recursive_merge_json__file(std::ofstream& out, const std::filesystem::directory_entry& file) {
    std::ifstream in(file.path(), std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << file.path() << "\n";
        return 1;
    }
    unsigned char c;
    while (in.get(reinterpret_cast<char&>(c))) {
        if (c == ' ' || c == '\r' || c == '\n' || c == '\t')
            continue;
        out << c;
    }
    return 0;
}

int ___recursive_merge_json__directory(std::ofstream& out, const std::filesystem::directory_entry& file) {
    out << "{";
    bool begin = true;
    for (const auto& f : std::filesystem::directory_iterator(file.path())) {
        if (!begin)
            out << ", ";
        begin = false;
        if (auto it = ___recursive_merge_json(out, f); it != 0) {
            if (it == 2)
                continue;
            return it;
        }
    }
    out << "}";
    return 0;
}

int ___recursive_merge_json(std::ofstream& out, const std::filesystem::directory_entry& file) {
    std::string key = file.path().filename().string();
    out << "\"" << key << "\": ";
    if (file.is_directory())
        return ___recursive_merge_json__directory(out, file);
    else
        return ___recursive_merge_json__file(out, file);
    return 0;
}

int ___recursive_merge_json(std::ofstream& out, const std::filesystem::path& file) {
    out << "{";
    bool begin = true;
    for (const auto& f : std::filesystem::directory_iterator(file)) {
        if (!begin)
            out << ", ";
        begin = false;
        if (auto it = ___recursive_merge_json(out, f); it != 0)
            return it;
    }
    out << "}";
    return 0;
}

int merge_json_resource(const resource_location& location, const std::filesystem::path& input_file) {
    std::filesystem::path tmp_file = location.output_path.parent_path() / (location.output_path.filename().string() + "_tmp.json");
    std::filesystem::path output_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".cpp");
    std::filesystem::path header_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".hpp");

    auto file_change_time = std::filesystem::last_write_time(input_file);

    std::filesystem::create_directories(output_file.parent_path());

    if (std::filesystem::exists(output_file) && std::filesystem::exists(header_file)) {
        auto output_file_time = std::filesystem::last_write_time(output_file);
        auto header_file_time = std::filesystem::last_write_time(header_file);
        if (file_change_time < output_file_time && file_change_time < header_file_time)
            return 0;
    }

    {
        std::ofstream out(tmp_file, std::ios::binary | std::ios::trunc);
        if (!out) {
            std::cerr << "Error opening output file: " << tmp_file << "\n";
            return 1;
        }

        if (auto it = ___recursive_merge_json(out, input_file); it != 0)
            return it;
    }

    std::cout << "Building resource: " << location.full_name << std::endl;

    std::ifstream in(tmp_file, std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << tmp_file << "\n";
        return 1;
    }

    std::ofstream out(output_file, std::ios::binary);
    if (!out) {
        std::cerr << "Error opening output file: " << output_file << "\n";
        return 1;
    }

    std::ofstream header(header_file, std::ios::binary);
    if (!header) {
        std::cerr << "Error opening header file: " << header_file << "\n";
        return 1;
    }

    out << "//!Autogenerated file, do not modify\n"
           "#include \""
        << location.output_path.filename().string() + ".hpp\"\n";
    out << location.namespace_open
        << "const unsigned char __" << location.name << "[] = {";
    unsigned char c;
    while (in.get(reinterpret_cast<char&>(c)))
        out << "0x" << std::hex << static_cast<int>((uint8_t)c) << ", ";
    out << "};\n";

    out << "const std::string_view " << location.name << "((char*)__" << location.name << ", sizeof(__" << location.name << "));\n";
    out << location.namespace_close;


    header << "//!Autogenerated file, do not modify\n";
    header << "#pragma once\n#include <string>\n";
    header << location.namespace_open
           << "extern const std::string_view " << location.name << ";\n";
    header << location.namespace_close;

    std::cout << "Resource built successfully: " << location.full_name << std::endl;
    return 0;
}

int senbt_resource(const resource_location& location, const std::filesystem::path& input_file, bool compress) {
    std::filesystem::path output_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".cpp");
    std::filesystem::path header_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".hpp");

    auto file_change_time = std::filesystem::last_write_time(input_file);

    std::filesystem::create_directories(output_file.parent_path());

    if (std::filesystem::exists(output_file) && std::filesystem::exists(header_file)) {
        auto output_file_time = std::filesystem::last_write_time(output_file);
        auto header_file_time = std::filesystem::last_write_time(header_file);
        if (file_change_time < output_file_time && file_change_time < header_file_time)
            return 0;
    }

    std::cout << "Building resource: " << location.full_name << std::endl;

    std::ifstream in(input_file, std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << input_file << "\n";
        return 1;
    }
    std::string senbt_data{std::istreambuf_iterator<char>(in), std::istreambuf_iterator<char>()};

    std::stringstream ss;
    {
        boost::iostreams::filtering_ostream filter;
        if (compress)
            filter.push(boost::iostreams::zstd_compressor());
        filter.push(ss);
        enbt::io_helper::write_token(filter, senbt::parse(senbt_data));
        filter.flush();
        ss.flush();
    }
    if (ss.bad()) {
        std::cerr << "Problem reading file: " << output_file << "\n";
        return 1;
    }


    std::ofstream out(output_file, std::ios::binary);
    if (!out) {
        std::cerr << "Error opening output file: " << output_file << "\n";
        return 1;
    }

    std::ofstream header(header_file, std::ios::binary);
    if (!header) {
        std::cerr << "Error opening header file: " << header_file << "\n";
        return 1;
    }

    out << "//!Autogenerated file, do not modify\n"
           "#include \""
        << location.output_path.filename().string() + ".hpp\"\n";
    out << location.namespace_open
        << "const unsigned char __" << location.name << "[] = {";
    unsigned char c;
    for (auto c : ss.str())
        out << "0x" << std::hex << static_cast<int>((uint8_t)c) << ", ";
    out << "};\n";

    out << "const std::string_view " << location.name << "((char*)__" << location.name << ", sizeof(__" << location.name << "));\n";
    out << location.namespace_close;


    header << "//!Autogenerated file, do not modify\n";
    header << "#pragma once\n#include <string>\n";
    header << location.namespace_open
           << "extern const std::string_view " << location.name << ";\n";
    header << location.namespace_close;

    std::cout << "Resource built successfully: " << location.full_name << std::endl;
    return 0;
}

int ___recursive_merge_senbt(std::ofstream& out, const std::filesystem::directory_entry& file);

int ___recursive_merge_senbt__file(std::ofstream& out, const std::filesystem::directory_entry& file) {
    std::ifstream in(file.path(), std::ios::binary);
    if (!in) {
        std::cerr << "Error opening input file: " << file.path() << "\n";
        return 1;
    }
    unsigned char c;
    while (in.get(reinterpret_cast<char&>(c))) {
        if (c == ' ' || c == '\r' || c == '\n' || c == '\t')
            continue;
        out << c;
    }
    return 0;
}

int ___recursive_merge_senbt__directory(std::ofstream& out, const std::filesystem::directory_entry& file) {
    out << "{";
    bool begin = true;
    for (const auto& f : std::filesystem::directory_iterator(file.path())) {
        if (!begin)
            out << ", ";
        begin = false;
        if (auto it = ___recursive_merge_senbt(out, f); it != 0) {
            if (it == 2)
                continue;
            return it;
        }
    }
    out << "}";
    return 0;
}

int ___recursive_merge_senbt(std::ofstream& out, const std::filesystem::directory_entry& file) {
    std::string key = file.path().filename().string();
    out << "\"" << key << "\": ";
    if (file.is_directory())
        return ___recursive_merge_senbt__directory(out, file);
    else
        return ___recursive_merge_senbt__file(out, file);
    return 0;
}

int ___recursive_merge_senbt(std::ofstream& out, const std::filesystem::path& file) {
    out << "{";
    bool begin = true;
    for (const auto& f : std::filesystem::directory_iterator(file)) {
        if (!begin)
            out << ", ";
        begin = false;
        if (auto it = ___recursive_merge_senbt(out, f); it != 0)
            return it;
    }
    out << "}";
    return 0;
}

int merge_senbt_resource(const resource_location& location, const std::filesystem::path& input_file, bool compress) {
    std::filesystem::path tmp_file = location.output_path.parent_path() / (location.output_path.filename().string() + "_tmp.enbt");
    std::filesystem::path output_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".cpp");
    std::filesystem::path header_file = location.output_path.parent_path() / (location.output_path.filename().string() + ".hpp");

    auto file_change_time = std::filesystem::last_write_time(input_file);

    std::filesystem::create_directories(output_file.parent_path());

    if (std::filesystem::exists(output_file) && std::filesystem::exists(header_file)) {
        auto output_file_time = std::filesystem::last_write_time(output_file);
        auto header_file_time = std::filesystem::last_write_time(header_file);
        if (file_change_time < output_file_time && file_change_time < header_file_time)
            return 0;
    }

    {
        std::ofstream out(tmp_file, std::ios::binary | std::ios::trunc);
        if (!out) {
            std::cerr << "Error opening output file: " << tmp_file << "\n";
            return 1;
        }

        if (auto it = ___recursive_merge_senbt(out, input_file); it != 0)
            return it;
    }
    return senbt_resource(location, tmp_file, compress);
}

int main(int argc, char* argv[]) {
    if (argc != 5 && argc != 6) {
        std::cerr << "Usage: " << argv[0] << " <direct/json/merge_json/senbt/merge_senbt> <project namespace> <input resource> <base_output_path> [compressed]\n";
        return 1;
    }
    bool compressed = false;
    if (argc == 6)
        compressed = (strcmp(argv[5], "compressed") == 0);

    std::filesystem::path input_file = argv[3];
    resource_location location = resource_location_extractor(argv[2], input_file, argv[4]);
    try {
        if (strcmp(argv[1], "direct") == 0)
            return direct_resource(location, input_file);
        else if (strcmp(argv[1], "json") == 0)
            return direct_resource(location, input_file, true);
        else if (strcmp(argv[1], "merge_json") == 0)
            return merge_json_resource(location, input_file);
        else if (strcmp(argv[1], "senbt") == 0)
            return senbt_resource(location, input_file, compressed);
        else if (strcmp(argv[1], "merge_senbt") == 0)
            return merge_senbt_resource(location, input_file, compressed);
        else {
            std::cerr << "Unknown command: " << argv[1] << "\n";
            return 1;
        }
    } catch (const std::exception& ex) {
        std::cout << "Failed to build resource: " << location.full_name << ", unexected error: " << ex.what()
                  << ", stack trace " << std::stacktrace::current() << std::endl;
        return 1;
    }

    return 0;
}
