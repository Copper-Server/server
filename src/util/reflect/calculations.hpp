// Generated by reflect_map tool
#pragma once
#include <string>
namespace copper_server::reflect{
template<class T, class FN>constexpr void for_each_field([[maybe_unused]] copper_server::util::XYZ<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
  fn(obj.z);
}
template<class T, class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::util::XYZ<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
  fn(obj.z);
}
template<class T>struct for_each_type_s<copper_server::util::XYZ<T>> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::XYZ<T>>().x)>();
  fn.template operator()<decltype(std::declval<copper_server::util::XYZ<T>>().y)>();
  fn.template operator()<decltype(std::declval<copper_server::util::XYZ<T>>().z)>();
}
};
template<class T>struct for_each_type_with_name_s<copper_server::util::XYZ<T>> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::XYZ<T>>().x)>("x");
  fn.template operator()<decltype(std::declval<copper_server::util::XYZ<T>>().y)>("y");
  fn.template operator()<decltype(std::declval<copper_server::util::XYZ<T>>().z)>("z");
}
};
template<class T, class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::util::XYZ<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
  fn(obj.z, "z");
}
template<class T, class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::util::XYZ<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
  fn(obj.z, "z");
}
template<class T, class FN>constexpr void for_each_field([[maybe_unused]] copper_server::util::XY<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
}
template<class T, class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::util::XY<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
}
template<class T>struct for_each_type_s<copper_server::util::XY<T>> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::XY<T>>().x)>();
  fn.template operator()<decltype(std::declval<copper_server::util::XY<T>>().y)>();
}
};
template<class T>struct for_each_type_with_name_s<copper_server::util::XY<T>> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::XY<T>>().x)>("x");
  fn.template operator()<decltype(std::declval<copper_server::util::XY<T>>().y)>("y");
}
};
template<class T, class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::util::XY<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
}
template<class T, class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::util::XY<T>& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
}
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::util::ANGLE_DEG& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::util::ANGLE_DEG& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
}
template<>struct for_each_type_s<copper_server::util::ANGLE_DEG> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_DEG>().x)>();
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_DEG>().y)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::util::ANGLE_DEG> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_DEG>().x)>("x");
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_DEG>().y)>("y");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::util::ANGLE_DEG& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::util::ANGLE_DEG& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
}
template<>consteval std::string_view type_name<copper_server::util::ANGLE_DEG>() { return "copper_server::util::ANGLE_DEG"; }
template<>consteval size_t fields_count<copper_server::util::ANGLE_DEG>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::util::ANGLE_RAD& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::util::ANGLE_RAD& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x);
  fn(obj.y);
}
template<>struct for_each_type_s<copper_server::util::ANGLE_RAD> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_RAD>().x)>();
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_RAD>().y)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::util::ANGLE_RAD> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_RAD>().x)>("x");
  fn.template operator()<decltype(std::declval<copper_server::util::ANGLE_RAD>().y)>("y");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::util::ANGLE_RAD& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::util::ANGLE_RAD& obj, [[maybe_unused]] FN&& fn){
  fn(obj.x, "x");
  fn(obj.y, "y");
}
template<>consteval std::string_view type_name<copper_server::util::ANGLE_RAD>() { return "copper_server::util::ANGLE_RAD"; }
template<>consteval size_t fields_count<copper_server::util::ANGLE_RAD>() { return 2; }
}
