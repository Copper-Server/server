// Generated by reflect_map tool
#pragma once
#include <string>
namespace copper_server::reflect{
template<>struct enum_data<copper_server::base_objects::item_firework_explosion::shape_e> {using item = std::pair<std::string_view, copper_server::base_objects::item_firework_explosion::shape_e>;
static constexpr inline std::array<item, 5> values = {item{"small_ball", copper_server::base_objects::item_firework_explosion::shape_e::small_ball}, item{"large_ball", copper_server::base_objects::item_firework_explosion::shape_e::large_ball}, item{"star", copper_server::base_objects::item_firework_explosion::shape_e::star}, item{"creeper", copper_server::base_objects::item_firework_explosion::shape_e::creeper}, item{"burst", copper_server::base_objects::item_firework_explosion::shape_e::burst}};};
template<>consteval std::string_view type_name<copper_server::base_objects::item_firework_explosion::shape_e>() { return "copper_server::base_objects::item_firework_explosion::shape_e"; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::item_firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.shape);
  fn(obj.colors);
  fn(obj.fade_colors);
  fn(obj.trail);
  fn(obj.twinkle);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::item_firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.shape);
  fn(obj.colors);
  fn(obj.fade_colors);
  fn(obj.trail);
  fn(obj.twinkle);
}
template<>struct for_each_type_s<copper_server::base_objects::item_firework_explosion> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().shape)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().colors)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().fade_colors)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().trail)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().twinkle)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::item_firework_explosion> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().shape)>("shape");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().colors)>("colors");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().fade_colors)>("fade_colors");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().trail)>("trail");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::item_firework_explosion>().twinkle)>("twinkle");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::item_firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.shape, "shape");
  fn(obj.colors, "colors");
  fn(obj.fade_colors, "fade_colors");
  fn(obj.trail, "trail");
  fn(obj.twinkle, "twinkle");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::item_firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.shape, "shape");
  fn(obj.colors, "colors");
  fn(obj.fade_colors, "fade_colors");
  fn(obj.trail, "trail");
  fn(obj.twinkle, "twinkle");
}
template<>consteval std::string_view type_name<copper_server::base_objects::item_firework_explosion>() { return "copper_server::base_objects::item_firework_explosion"; }
template<>consteval size_t fields_count<copper_server::base_objects::item_firework_explosion>() { return 5; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::sound_event& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.fixed_range);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::sound_event& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.fixed_range);
}
template<>struct for_each_type_s<copper_server::base_objects::sound_event> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::sound_event>().name)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::sound_event>().fixed_range)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::sound_event> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::sound_event>().name)>("name");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::sound_event>().fixed_range)>("fixed_range");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::sound_event& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.fixed_range, "fixed_range");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::sound_event& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.fixed_range, "fixed_range");
}
template<>consteval std::string_view type_name<copper_server::base_objects::sound_event>() { return "copper_server::base_objects::sound_event"; }
template<>consteval size_t fields_count<copper_server::base_objects::sound_event>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::potion_effect::data_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier);
  fn(obj.duration);
  fn(obj.is_ambient);
  fn(obj.show_particles);
  fn(obj.show_icon);
  fn(obj.hidden_effect);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::potion_effect::data_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier);
  fn(obj.duration);
  fn(obj.is_ambient);
  fn(obj.show_particles);
  fn(obj.show_icon);
  fn(obj.hidden_effect);
}
template<>struct for_each_type_s<copper_server::base_objects::potion_effect::data_t> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().amplifier)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().duration)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().is_ambient)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().show_particles)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().show_icon)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().hidden_effect)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::potion_effect::data_t> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().amplifier)>("amplifier");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().duration)>("duration");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().is_ambient)>("is_ambient");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().show_particles)>("show_particles");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().show_icon)>("show_icon");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect::data_t>().hidden_effect)>("hidden_effect");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::potion_effect::data_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier, "amplifier");
  fn(obj.duration, "duration");
  fn(obj.is_ambient, "is_ambient");
  fn(obj.show_particles, "show_particles");
  fn(obj.show_icon, "show_icon");
  fn(obj.hidden_effect, "hidden_effect");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::potion_effect::data_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier, "amplifier");
  fn(obj.duration, "duration");
  fn(obj.is_ambient, "is_ambient");
  fn(obj.show_particles, "show_particles");
  fn(obj.show_icon, "show_icon");
  fn(obj.hidden_effect, "hidden_effect");
}
template<>consteval std::string_view type_name<copper_server::base_objects::potion_effect::data_t>() { return "copper_server::base_objects::potion_effect::data_t"; }
template<>consteval size_t fields_count<copper_server::base_objects::potion_effect::data_t>() { return 6; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::potion_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type_id);
  fn(obj.data);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::potion_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type_id);
  fn(obj.data);
}
template<>struct for_each_type_s<copper_server::base_objects::potion_effect> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect>().type_id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect>().data)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::potion_effect> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect>().type_id)>("type_id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::potion_effect>().data)>("data");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::potion_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type_id, "type_id");
  fn(obj.data, "data");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::potion_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type_id, "type_id");
  fn(obj.data, "data");
}
template<>consteval std::string_view type_name<copper_server::base_objects::potion_effect>() { return "copper_server::base_objects::potion_effect"; }
template<>consteval size_t fields_count<copper_server::base_objects::potion_effect>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::consume_effect::apply_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
  fn(obj.probability);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::consume_effect::apply_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
  fn(obj.probability);
}
template<>struct for_each_type_s<copper_server::base_objects::consume_effect::apply_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::apply_effects>().effects)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::apply_effects>().probability)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::consume_effect::apply_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::apply_effects>().effects)>("effects");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::apply_effects>().probability)>("probability");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::consume_effect::apply_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
  fn(obj.probability, "probability");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::consume_effect::apply_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
  fn(obj.probability, "probability");
}
template<>consteval std::string_view type_name<copper_server::base_objects::consume_effect::apply_effects>() { return "copper_server::base_objects::consume_effect::apply_effects"; }
template<>consteval size_t fields_count<copper_server::base_objects::consume_effect::apply_effects>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::consume_effect::remove_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::consume_effect::remove_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
}
template<>struct for_each_type_s<copper_server::base_objects::consume_effect::remove_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::remove_effects>().effects)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::consume_effect::remove_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::remove_effects>().effects)>("effects");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::consume_effect::remove_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::consume_effect::remove_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
}
template<>consteval std::string_view type_name<copper_server::base_objects::consume_effect::remove_effects>() { return "copper_server::base_objects::consume_effect::remove_effects"; }
template<>consteval size_t fields_count<copper_server::base_objects::consume_effect::remove_effects>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::consume_effect::clear_all_effects& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::consume_effect::clear_all_effects& obj, [[maybe_unused]] FN&& fn){
}
template<>struct for_each_type_s<copper_server::base_objects::consume_effect::clear_all_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::consume_effect::clear_all_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::consume_effect::clear_all_effects& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::consume_effect::clear_all_effects& obj, [[maybe_unused]] FN&& fn){
}
template<>consteval std::string_view type_name<copper_server::base_objects::consume_effect::clear_all_effects>() { return "copper_server::base_objects::consume_effect::clear_all_effects"; }
template<>consteval size_t fields_count<copper_server::base_objects::consume_effect::clear_all_effects>() { return 0; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::consume_effect::teleport_randomly& obj, [[maybe_unused]] FN&& fn){
  fn(obj.diameter);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::consume_effect::teleport_randomly& obj, [[maybe_unused]] FN&& fn){
  fn(obj.diameter);
}
template<>struct for_each_type_s<copper_server::base_objects::consume_effect::teleport_randomly> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::teleport_randomly>().diameter)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::consume_effect::teleport_randomly> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::teleport_randomly>().diameter)>("diameter");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::consume_effect::teleport_randomly& obj, [[maybe_unused]] FN&& fn){
  fn(obj.diameter, "diameter");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::consume_effect::teleport_randomly& obj, [[maybe_unused]] FN&& fn){
  fn(obj.diameter, "diameter");
}
template<>consteval std::string_view type_name<copper_server::base_objects::consume_effect::teleport_randomly>() { return "copper_server::base_objects::consume_effect::teleport_randomly"; }
template<>consteval size_t fields_count<copper_server::base_objects::consume_effect::teleport_randomly>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::consume_effect::play_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.event);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::consume_effect::play_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.event);
}
template<>struct for_each_type_s<copper_server::base_objects::consume_effect::play_sound> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::play_sound>().event)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::consume_effect::play_sound> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect::play_sound>().event)>("event");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::consume_effect::play_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.event, "event");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::consume_effect::play_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.event, "event");
}
template<>consteval std::string_view type_name<copper_server::base_objects::consume_effect::play_sound>() { return "copper_server::base_objects::consume_effect::play_sound"; }
template<>consteval size_t fields_count<copper_server::base_objects::consume_effect::play_sound>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::consume_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effect);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::consume_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effect);
}
template<>struct for_each_type_s<copper_server::base_objects::consume_effect> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect>().effect)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::consume_effect> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::consume_effect>().effect)>("effect");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::consume_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effect, "effect");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::consume_effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effect, "effect");
}
template<>consteval std::string_view type_name<copper_server::base_objects::consume_effect>() { return "copper_server::base_objects::consume_effect"; }
template<>consteval size_t fields_count<copper_server::base_objects::consume_effect>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::partial_component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type);
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::partial_component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type);
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::partial_component> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::partial_component>().type)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::partial_component>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::partial_component> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::partial_component>().type)>("type");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::partial_component>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::partial_component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type, "type");
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::partial_component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type, "type");
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::partial_component>() { return "copper_server::base_objects::partial_component"; }
template<>consteval size_t fields_count<copper_server::base_objects::partial_component>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::weak_slot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.count);
  fn(obj.id);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::weak_slot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.count);
  fn(obj.id);
}
template<>struct for_each_type_s<copper_server::base_objects::weak_slot> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::weak_slot>().count)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::weak_slot>().id)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::weak_slot> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::weak_slot>().count)>("count");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::weak_slot>().id)>("id");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::weak_slot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.count, "count");
  fn(obj.id, "id");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::weak_slot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.count, "count");
  fn(obj.id, "id");
}
template<>consteval std::string_view type_name<copper_server::base_objects::weak_slot>() { return "copper_server::base_objects::weak_slot"; }
template<>consteval size_t fields_count<copper_server::base_objects::weak_slot>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::trim_material::override_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material_type);
  fn(obj.asset_name);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::trim_material::override_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material_type);
  fn(obj.asset_name);
}
template<>struct for_each_type_s<copper_server::base_objects::trim_material::override_t> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material::override_t>().material_type)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material::override_t>().asset_name)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::trim_material::override_t> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material::override_t>().material_type)>("material_type");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material::override_t>().asset_name)>("asset_name");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::trim_material::override_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material_type, "material_type");
  fn(obj.asset_name, "asset_name");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::trim_material::override_t& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material_type, "material_type");
  fn(obj.asset_name, "asset_name");
}
template<>consteval std::string_view type_name<copper_server::base_objects::trim_material::override_t>() { return "copper_server::base_objects::trim_material::override_t"; }
template<>consteval size_t fields_count<copper_server::base_objects::trim_material::override_t>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.suffix);
  fn(obj.overrides);
  fn(obj.description);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.suffix);
  fn(obj.overrides);
  fn(obj.description);
}
template<>struct for_each_type_s<copper_server::base_objects::trim_material> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material>().suffix)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material>().overrides)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material>().description)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::trim_material> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material>().suffix)>("suffix");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material>().overrides)>("overrides");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_material>().description)>("description");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.suffix, "suffix");
  fn(obj.overrides, "overrides");
  fn(obj.description, "description");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.suffix, "suffix");
  fn(obj.overrides, "overrides");
  fn(obj.description, "description");
}
template<>consteval std::string_view type_name<copper_server::base_objects::trim_material>() { return "copper_server::base_objects::trim_material"; }
template<>consteval size_t fields_count<copper_server::base_objects::trim_material>() { return 3; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::trim_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_name);
  fn(obj.template_item);
  fn(obj.description);
  fn(obj.decal);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::trim_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_name);
  fn(obj.template_item);
  fn(obj.description);
  fn(obj.decal);
}
template<>struct for_each_type_s<copper_server::base_objects::trim_pattern> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().asset_name)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().template_item)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().description)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().decal)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::trim_pattern> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().asset_name)>("asset_name");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().template_item)>("template_item");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().description)>("description");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::trim_pattern>().decal)>("decal");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::trim_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_name, "asset_name");
  fn(obj.template_item, "template_item");
  fn(obj.description, "description");
  fn(obj.decal, "decal");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::trim_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_name, "asset_name");
  fn(obj.template_item, "template_item");
  fn(obj.description, "description");
  fn(obj.decal, "decal");
}
template<>consteval std::string_view type_name<copper_server::base_objects::trim_pattern>() { return "copper_server::base_objects::trim_pattern"; }
template<>consteval size_t fields_count<copper_server::base_objects::trim_pattern>() { return 4; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
  fn(obj.sound_range);
  fn(obj.instrument_range);
  fn(obj.description);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
  fn(obj.sound_range);
  fn(obj.instrument_range);
  fn(obj.description);
}
template<>struct for_each_type_s<copper_server::base_objects::instrument> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().sound)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().sound_range)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().instrument_range)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().description)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::instrument> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().sound)>("sound");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().sound_range)>("sound_range");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().instrument_range)>("instrument_range");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::instrument>().description)>("description");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
  fn(obj.sound_range, "sound_range");
  fn(obj.instrument_range, "instrument_range");
  fn(obj.description, "description");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
  fn(obj.sound_range, "sound_range");
  fn(obj.instrument_range, "instrument_range");
  fn(obj.description, "description");
}
template<>consteval std::string_view type_name<copper_server::base_objects::instrument>() { return "copper_server::base_objects::instrument"; }
template<>consteval size_t fields_count<copper_server::base_objects::instrument>() { return 4; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::jukebox_song& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
  fn(obj.description);
  fn(obj.duration);
  fn(obj.output);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::jukebox_song& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
  fn(obj.description);
  fn(obj.duration);
  fn(obj.output);
}
template<>struct for_each_type_s<copper_server::base_objects::jukebox_song> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().sound)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().description)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().duration)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().output)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::jukebox_song> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().sound)>("sound");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().description)>("description");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().duration)>("duration");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::jukebox_song>().output)>("output");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::jukebox_song& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
  fn(obj.description, "description");
  fn(obj.duration, "duration");
  fn(obj.output, "output");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::jukebox_song& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
  fn(obj.description, "description");
  fn(obj.duration, "duration");
  fn(obj.output, "output");
}
template<>consteval std::string_view type_name<copper_server::base_objects::jukebox_song>() { return "copper_server::base_objects::jukebox_song"; }
template<>consteval size_t fields_count<copper_server::base_objects::jukebox_song>() { return 4; }
template<util::CTS custom_name, class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component_custom_name<custom_name>& obj, [[maybe_unused]] FN&& fn){
}
template<util::CTS custom_name, class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component_custom_name<custom_name>& obj, [[maybe_unused]] FN&& fn){
}
template<util::CTS custom_name>struct for_each_type_s<copper_server::base_objects::component_custom_name<custom_name>> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<util::CTS custom_name>struct for_each_type_with_name_s<copper_server::base_objects::component_custom_name<custom_name>> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<util::CTS custom_name, class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component_custom_name<custom_name>& obj, [[maybe_unused]] FN&& fn){
}
template<util::CTS custom_name, class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component_custom_name<custom_name>& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::custom_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::custom_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<>struct for_each_type_s<copper_server::base_objects::component::custom_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_data>().data)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::custom_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_data>().data)>("data");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::custom_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::custom_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::custom_data>() { return "copper_server::base_objects::component::custom_data"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::custom_data>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::max_stack_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::max_stack_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size);
}
template<>struct for_each_type_s<copper_server::base_objects::component::max_stack_size> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::max_stack_size>().size)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::max_stack_size> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::max_stack_size>().size)>("size");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::max_stack_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size, "size");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::max_stack_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size, "size");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::max_stack_size>() { return "copper_server::base_objects::component::max_stack_size"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::max_stack_size>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::max_damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::max_damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg);
}
template<>struct for_each_type_s<copper_server::base_objects::component::max_damage> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::max_damage>().dmg)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::max_damage> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::max_damage>().dmg)>("dmg");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::max_damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg, "dmg");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::max_damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg, "dmg");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::max_damage>() { return "copper_server::base_objects::component::max_damage"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::max_damage>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg);
}
template<>struct for_each_type_s<copper_server::base_objects::component::damage> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::damage>().dmg)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::damage> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::damage>().dmg)>("dmg");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg, "dmg");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::damage& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg, "dmg");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::damage>() { return "copper_server::base_objects::component::damage"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::damage>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::unbreakable& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::unbreakable& obj, [[maybe_unused]] FN&& fn){
}
template<>struct for_each_type_s<copper_server::base_objects::component::unbreakable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::unbreakable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::unbreakable& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::unbreakable& obj, [[maybe_unused]] FN&& fn){
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::unbreakable>() { return "copper_server::base_objects::component::unbreakable"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::unbreakable>() { return 0; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::custom_name& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::custom_name& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<>struct for_each_type_s<copper_server::base_objects::component::custom_name> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_name>().name)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::custom_name> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_name>().name)>("name");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::custom_name& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::custom_name& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::custom_name>() { return "copper_server::base_objects::component::custom_name"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::custom_name>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::item_model& obj, [[maybe_unused]] FN&& fn){
  fn(obj.model);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::item_model& obj, [[maybe_unused]] FN&& fn){
  fn(obj.model);
}
template<>struct for_each_type_s<copper_server::base_objects::component::item_model> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::item_model>().model)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::item_model> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::item_model>().model)>("model");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::item_model& obj, [[maybe_unused]] FN&& fn){
  fn(obj.model, "model");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::item_model& obj, [[maybe_unused]] FN&& fn){
  fn(obj.model, "model");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::item_model>() { return "copper_server::base_objects::component::item_model"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::item_model>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::lore& obj, [[maybe_unused]] FN&& fn){
  fn(obj.lines);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::lore& obj, [[maybe_unused]] FN&& fn){
  fn(obj.lines);
}
template<>struct for_each_type_s<copper_server::base_objects::component::lore> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lore>().lines)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::lore> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lore>().lines)>("lines");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::lore& obj, [[maybe_unused]] FN&& fn){
  fn(obj.lines, "lines");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::lore& obj, [[maybe_unused]] FN&& fn){
  fn(obj.lines, "lines");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::lore>() { return "copper_server::base_objects::component::lore"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::lore>() { return 1; }
template<>struct enum_data<copper_server::base_objects::component::rarity::rarity_e> {using item = std::pair<std::string_view, copper_server::base_objects::component::rarity::rarity_e>;
static constexpr inline std::array<item, 4> values = {item{"common", copper_server::base_objects::component::rarity::rarity_e::common}, item{"uncommon", copper_server::base_objects::component::rarity::rarity_e::uncommon}, item{"rare", copper_server::base_objects::component::rarity::rarity_e::rare}, item{"epic", copper_server::base_objects::component::rarity::rarity_e::epic}};};
template<>consteval std::string_view type_name<copper_server::base_objects::component::rarity::rarity_e>() { return "copper_server::base_objects::component::rarity::rarity_e"; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::rarity& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rarity);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::rarity& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rarity);
}
template<>struct for_each_type_s<copper_server::base_objects::component::rarity> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::rarity>().rarity)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::rarity> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::rarity>().rarity)>("rarity");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::rarity& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rarity, "rarity");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::rarity& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rarity, "rarity");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::rarity>() { return "copper_server::base_objects::component::rarity"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::rarity>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
  fn(obj.level);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
  fn(obj.level);
}
template<>struct for_each_type_s<copper_server::base_objects::component::enchantments::enchantment> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantments::enchantment>().id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantments::enchantment>().level)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::enchantments::enchantment> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantments::enchantment>().id)>("id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantments::enchantment>().level)>("level");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
  fn(obj.level, "level");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
  fn(obj.level, "level");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::enchantments::enchantment>() { return "copper_server::base_objects::component::enchantments::enchantment"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::enchantments::enchantment>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments);
}
template<>struct for_each_type_s<copper_server::base_objects::component::enchantments> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantments>().enchantments)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::enchantments> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantments>().enchantments)>("enchantments");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments, "enchantments");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments, "enchantments");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::enchantments>() { return "copper_server::base_objects::component::enchantments"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::enchantments>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_place_on::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min);
  fn(obj.max);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_place_on::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min);
  fn(obj.max);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_place_on::property::range> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property::range>().min)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property::range>().max)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_place_on::property::range> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property::range>().min)>("min");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property::range>().max)>("max");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_place_on::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min, "min");
  fn(obj.max, "max");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_place_on::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min, "min");
  fn(obj.max, "max");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_place_on::property::range>() { return "copper_server::base_objects::component::can_place_on::property::range"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_place_on::property::range>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_place_on::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_place_on::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_place_on::property::exact> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property::exact>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_place_on::property::exact> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property::exact>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_place_on::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_place_on::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_place_on::property::exact>() { return "copper_server::base_objects::component::can_place_on::property::exact"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_place_on::property::exact>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_place_on::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.is_exact);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_place_on::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.is_exact);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_place_on::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property>().name)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property>().is_exact)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_place_on::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property>().name)>("name");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on::property>().is_exact)>("is_exact");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_place_on::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.is_exact, "is_exact");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_place_on::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.is_exact, "is_exact");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_place_on::property>() { return "copper_server::base_objects::component::can_place_on::property"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_place_on::property>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_place_on& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks);
  fn(obj.properties);
  fn(obj.nbt);
  fn(obj.full_components_match);
  fn(obj.partial_components_match);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_place_on& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks);
  fn(obj.properties);
  fn(obj.nbt);
  fn(obj.full_components_match);
  fn(obj.partial_components_match);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_place_on> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().blocks)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().properties)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().nbt)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().full_components_match)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().partial_components_match)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_place_on> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().blocks)>("blocks");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().properties)>("properties");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().nbt)>("nbt");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().full_components_match)>("full_components_match");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_place_on>().partial_components_match)>("partial_components_match");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_place_on& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks, "blocks");
  fn(obj.properties, "properties");
  fn(obj.nbt, "nbt");
  fn(obj.full_components_match, "full_components_match");
  fn(obj.partial_components_match, "partial_components_match");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_place_on& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks, "blocks");
  fn(obj.properties, "properties");
  fn(obj.nbt, "nbt");
  fn(obj.full_components_match, "full_components_match");
  fn(obj.partial_components_match, "partial_components_match");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_place_on>() { return "copper_server::base_objects::component::can_place_on"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_place_on>() { return 5; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_break::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min);
  fn(obj.max);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_break::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min);
  fn(obj.max);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_break::property::range> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property::range>().min)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property::range>().max)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_break::property::range> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property::range>().min)>("min");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property::range>().max)>("max");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_break::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min, "min");
  fn(obj.max, "max");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_break::property::range& obj, [[maybe_unused]] FN&& fn){
  fn(obj.min, "min");
  fn(obj.max, "max");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_break::property::range>() { return "copper_server::base_objects::component::can_break::property::range"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_break::property::range>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_break::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_break::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_break::property::exact> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property::exact>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_break::property::exact> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property::exact>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_break::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_break::property::exact& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_break::property::exact>() { return "copper_server::base_objects::component::can_break::property::exact"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_break::property::exact>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_break::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.is_exact);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_break::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.is_exact);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_break::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property>().name)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property>().is_exact)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_break::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property>().name)>("name");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break::property>().is_exact)>("is_exact");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_break::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.is_exact, "is_exact");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_break::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.is_exact, "is_exact");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_break::property>() { return "copper_server::base_objects::component::can_break::property"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_break::property>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::can_break& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks);
  fn(obj.properties);
  fn(obj.nbt);
  fn(obj.full_components_match);
  fn(obj.partial_components_match);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::can_break& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks);
  fn(obj.properties);
  fn(obj.nbt);
  fn(obj.full_components_match);
  fn(obj.partial_components_match);
}
template<>struct for_each_type_s<copper_server::base_objects::component::can_break> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().blocks)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().properties)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().nbt)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().full_components_match)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().partial_components_match)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::can_break> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().blocks)>("blocks");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().properties)>("properties");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().nbt)>("nbt");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().full_components_match)>("full_components_match");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::can_break>().partial_components_match)>("partial_components_match");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::can_break& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks, "blocks");
  fn(obj.properties, "properties");
  fn(obj.nbt, "nbt");
  fn(obj.full_components_match, "full_components_match");
  fn(obj.partial_components_match, "partial_components_match");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::can_break& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks, "blocks");
  fn(obj.properties, "properties");
  fn(obj.nbt, "nbt");
  fn(obj.full_components_match, "full_components_match");
  fn(obj.partial_components_match, "partial_components_match");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::can_break>() { return "copper_server::base_objects::component::can_break"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::can_break>() { return 5; }
template<>struct enum_data<copper_server::base_objects::component::attribute_modifiers::attribute::operation_e> {using item = std::pair<std::string_view, copper_server::base_objects::component::attribute_modifiers::attribute::operation_e>;
static constexpr inline std::array<item, 3> values = {item{"add", copper_server::base_objects::component::attribute_modifiers::attribute::operation_e::add}, item{"multiply_base", copper_server::base_objects::component::attribute_modifiers::attribute::operation_e::multiply_base}, item{"multiply_total", copper_server::base_objects::component::attribute_modifiers::attribute::operation_e::multiply_total}};};
template<>consteval std::string_view type_name<copper_server::base_objects::component::attribute_modifiers::attribute::operation_e>() { return "copper_server::base_objects::component::attribute_modifiers::attribute::operation_e"; }
template<>struct enum_data<copper_server::base_objects::component::attribute_modifiers::attribute::slot_e> {using item = std::pair<std::string_view, copper_server::base_objects::component::attribute_modifiers::attribute::slot_e>;
static constexpr inline std::array<item, 10> values = {item{"any", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::any}, item{"main_hand", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::main_hand}, item{"off_hand", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::off_hand}, item{"hand", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::hand}, item{"feet", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::feet}, item{"legs", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::legs}, item{"chest", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::chest}, item{"head", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::head}, item{"armor", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::armor}, item{"body", copper_server::base_objects::component::attribute_modifiers::attribute::slot_e::body}};};
template<>consteval std::string_view type_name<copper_server::base_objects::component::attribute_modifiers::attribute::slot_e>() { return "copper_server::base_objects::component::attribute_modifiers::attribute::slot_e"; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::attribute_modifiers::attribute& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attr_id);
  fn(obj.modifier_id);
  fn(obj.value);
  fn(obj.operation);
  fn(obj.slot);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::attribute_modifiers::attribute& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attr_id);
  fn(obj.modifier_id);
  fn(obj.value);
  fn(obj.operation);
  fn(obj.slot);
}
template<>struct for_each_type_s<copper_server::base_objects::component::attribute_modifiers::attribute> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().attr_id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().modifier_id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().value)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().operation)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().slot)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::attribute_modifiers::attribute> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().attr_id)>("attr_id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().modifier_id)>("modifier_id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().value)>("value");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().operation)>("operation");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers::attribute>().slot)>("slot");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::attribute_modifiers::attribute& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attr_id, "attr_id");
  fn(obj.modifier_id, "modifier_id");
  fn(obj.value, "value");
  fn(obj.operation, "operation");
  fn(obj.slot, "slot");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::attribute_modifiers::attribute& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attr_id, "attr_id");
  fn(obj.modifier_id, "modifier_id");
  fn(obj.value, "value");
  fn(obj.operation, "operation");
  fn(obj.slot, "slot");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::attribute_modifiers::attribute>() { return "copper_server::base_objects::component::attribute_modifiers::attribute"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::attribute_modifiers::attribute>() { return 5; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::attribute_modifiers& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attributes);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::attribute_modifiers& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attributes);
}
template<>struct for_each_type_s<copper_server::base_objects::component::attribute_modifiers> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers>().attributes)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::attribute_modifiers> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::attribute_modifiers>().attributes)>("attributes");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::attribute_modifiers& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attributes, "attributes");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::attribute_modifiers& obj, [[maybe_unused]] FN&& fn){
  fn(obj.attributes, "attributes");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::attribute_modifiers>() { return "copper_server::base_objects::component::attribute_modifiers"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::attribute_modifiers>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::custom_model_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.floats);
  fn(obj.flags);
  fn(obj.strings);
  fn(obj.colors);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::custom_model_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.floats);
  fn(obj.flags);
  fn(obj.strings);
  fn(obj.colors);
}
template<>struct for_each_type_s<copper_server::base_objects::component::custom_model_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().floats)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().flags)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().strings)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().colors)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::custom_model_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().floats)>("floats");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().flags)>("flags");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().strings)>("strings");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::custom_model_data>().colors)>("colors");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::custom_model_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.floats, "floats");
  fn(obj.flags, "flags");
  fn(obj.strings, "strings");
  fn(obj.colors, "colors");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::custom_model_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.floats, "floats");
  fn(obj.flags, "flags");
  fn(obj.strings, "strings");
  fn(obj.colors, "colors");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::custom_model_data>() { return "copper_server::base_objects::component::custom_model_data"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::custom_model_data>() { return 4; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::tooltip_display& obj, [[maybe_unused]] FN&& fn){
  fn(obj.hide_tooltip);
  fn(obj.hidden_components);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::tooltip_display& obj, [[maybe_unused]] FN&& fn){
  fn(obj.hide_tooltip);
  fn(obj.hidden_components);
}
template<>struct for_each_type_s<copper_server::base_objects::component::tooltip_display> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tooltip_display>().hide_tooltip)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tooltip_display>().hidden_components)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::tooltip_display> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tooltip_display>().hide_tooltip)>("hide_tooltip");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tooltip_display>().hidden_components)>("hidden_components");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::tooltip_display& obj, [[maybe_unused]] FN&& fn){
  fn(obj.hide_tooltip, "hide_tooltip");
  fn(obj.hidden_components, "hidden_components");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::tooltip_display& obj, [[maybe_unused]] FN&& fn){
  fn(obj.hide_tooltip, "hide_tooltip");
  fn(obj.hidden_components, "hidden_components");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::tooltip_display>() { return "copper_server::base_objects::component::tooltip_display"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::tooltip_display>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::repair_cost& obj, [[maybe_unused]] FN&& fn){
  fn(obj.cost);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::repair_cost& obj, [[maybe_unused]] FN&& fn){
  fn(obj.cost);
}
template<>struct for_each_type_s<copper_server::base_objects::component::repair_cost> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::repair_cost>().cost)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::repair_cost> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::repair_cost>().cost)>("cost");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::repair_cost& obj, [[maybe_unused]] FN&& fn){
  fn(obj.cost, "cost");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::repair_cost& obj, [[maybe_unused]] FN&& fn){
  fn(obj.cost, "cost");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::repair_cost>() { return "copper_server::base_objects::component::repair_cost"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::repair_cost>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::creative_slot_lock& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::creative_slot_lock& obj, [[maybe_unused]] FN&& fn){
}
template<>struct for_each_type_s<copper_server::base_objects::component::creative_slot_lock> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::creative_slot_lock> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::creative_slot_lock& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::creative_slot_lock& obj, [[maybe_unused]] FN&& fn){
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::creative_slot_lock>() { return "copper_server::base_objects::component::creative_slot_lock"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::creative_slot_lock>() { return 0; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::enchantment_glint_override& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::enchantment_glint_override& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has);
}
template<>struct for_each_type_s<copper_server::base_objects::component::enchantment_glint_override> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantment_glint_override>().has)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::enchantment_glint_override> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantment_glint_override>().has)>("has");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::enchantment_glint_override& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has, "has");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::enchantment_glint_override& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has, "has");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::enchantment_glint_override>() { return "copper_server::base_objects::component::enchantment_glint_override"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::enchantment_glint_override>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::intangible_projectile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value_compound);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::intangible_projectile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value_compound);
}
template<>struct for_each_type_s<copper_server::base_objects::component::intangible_projectile> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::intangible_projectile>().value_compound)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::intangible_projectile> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::intangible_projectile>().value_compound)>("value_compound");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::intangible_projectile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value_compound, "value_compound");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::intangible_projectile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value_compound, "value_compound");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::intangible_projectile>() { return "copper_server::base_objects::component::intangible_projectile"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::intangible_projectile>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::food& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nutrition);
  fn(obj.saturation_modifier);
  fn(obj.can_always_eat);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::food& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nutrition);
  fn(obj.saturation_modifier);
  fn(obj.can_always_eat);
}
template<>struct for_each_type_s<copper_server::base_objects::component::food> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::food>().nutrition)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::food>().saturation_modifier)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::food>().can_always_eat)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::food> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::food>().nutrition)>("nutrition");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::food>().saturation_modifier)>("saturation_modifier");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::food>().can_always_eat)>("can_always_eat");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::food& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nutrition, "nutrition");
  fn(obj.saturation_modifier, "saturation_modifier");
  fn(obj.can_always_eat, "can_always_eat");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::food& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nutrition, "nutrition");
  fn(obj.saturation_modifier, "saturation_modifier");
  fn(obj.can_always_eat, "can_always_eat");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::food>() { return "copper_server::base_objects::component::food"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::food>() { return 3; }
template<>struct enum_data<copper_server::base_objects::component::consumable::animation_e> {using item = std::pair<std::string_view, copper_server::base_objects::component::consumable::animation_e>;
static constexpr inline std::array<item, 10> values = {item{"none", copper_server::base_objects::component::consumable::animation_e::none}, item{"eat", copper_server::base_objects::component::consumable::animation_e::eat}, item{"dring", copper_server::base_objects::component::consumable::animation_e::dring}, item{"block", copper_server::base_objects::component::consumable::animation_e::block}, item{"bow", copper_server::base_objects::component::consumable::animation_e::bow}, item{"spear", copper_server::base_objects::component::consumable::animation_e::spear}, item{"crossbow", copper_server::base_objects::component::consumable::animation_e::crossbow}, item{"spyglass", copper_server::base_objects::component::consumable::animation_e::spyglass}, item{"toot_horn", copper_server::base_objects::component::consumable::animation_e::toot_horn}, item{"brush", copper_server::base_objects::component::consumable::animation_e::brush}};};
template<>consteval std::string_view type_name<copper_server::base_objects::component::consumable::animation_e>() { return "copper_server::base_objects::component::consumable::animation_e"; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::consumable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.consume_seconds);
  fn(obj.animation);
  fn(obj.sound);
  fn(obj.has_particles);
  fn(obj.effects);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::consumable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.consume_seconds);
  fn(obj.animation);
  fn(obj.sound);
  fn(obj.has_particles);
  fn(obj.effects);
}
template<>struct for_each_type_s<copper_server::base_objects::component::consumable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().consume_seconds)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().animation)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().sound)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().has_particles)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().effects)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::consumable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().consume_seconds)>("consume_seconds");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().animation)>("animation");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().sound)>("sound");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().has_particles)>("has_particles");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::consumable>().effects)>("effects");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::consumable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.consume_seconds, "consume_seconds");
  fn(obj.animation, "animation");
  fn(obj.sound, "sound");
  fn(obj.has_particles, "has_particles");
  fn(obj.effects, "effects");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::consumable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.consume_seconds, "consume_seconds");
  fn(obj.animation, "animation");
  fn(obj.sound, "sound");
  fn(obj.has_particles, "has_particles");
  fn(obj.effects, "effects");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::consumable>() { return "copper_server::base_objects::component::consumable"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::consumable>() { return 5; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::use_remainder& obj, [[maybe_unused]] FN&& fn){
  fn(obj.remainder);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::use_remainder& obj, [[maybe_unused]] FN&& fn){
  fn(obj.remainder);
}
template<>struct for_each_type_s<copper_server::base_objects::component::use_remainder> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::use_remainder>().remainder)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::use_remainder> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::use_remainder>().remainder)>("remainder");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::use_remainder& obj, [[maybe_unused]] FN&& fn){
  fn(obj.remainder, "remainder");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::use_remainder& obj, [[maybe_unused]] FN&& fn){
  fn(obj.remainder, "remainder");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::use_remainder>() { return "copper_server::base_objects::component::use_remainder"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::use_remainder>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::use_cooldown& obj, [[maybe_unused]] FN&& fn){
  fn(obj.seconds);
  fn(obj.cooldown_group);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::use_cooldown& obj, [[maybe_unused]] FN&& fn){
  fn(obj.seconds);
  fn(obj.cooldown_group);
}
template<>struct for_each_type_s<copper_server::base_objects::component::use_cooldown> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::use_cooldown>().seconds)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::use_cooldown>().cooldown_group)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::use_cooldown> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::use_cooldown>().seconds)>("seconds");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::use_cooldown>().cooldown_group)>("cooldown_group");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::use_cooldown& obj, [[maybe_unused]] FN&& fn){
  fn(obj.seconds, "seconds");
  fn(obj.cooldown_group, "cooldown_group");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::use_cooldown& obj, [[maybe_unused]] FN&& fn){
  fn(obj.seconds, "seconds");
  fn(obj.cooldown_group, "cooldown_group");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::use_cooldown>() { return "copper_server::base_objects::component::use_cooldown"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::use_cooldown>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::damage_resistant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.types);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::damage_resistant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.types);
}
template<>struct for_each_type_s<copper_server::base_objects::component::damage_resistant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::damage_resistant>().types)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::damage_resistant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::damage_resistant>().types)>("types");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::damage_resistant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.types, "types");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::damage_resistant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.types, "types");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::damage_resistant>() { return "copper_server::base_objects::component::damage_resistant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::damage_resistant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::tool::rule& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks);
  fn(obj.speed);
  fn(obj.correct_drop_for_blocks);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::tool::rule& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks);
  fn(obj.speed);
  fn(obj.correct_drop_for_blocks);
}
template<>struct for_each_type_s<copper_server::base_objects::component::tool::rule> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool::rule>().blocks)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool::rule>().speed)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool::rule>().correct_drop_for_blocks)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::tool::rule> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool::rule>().blocks)>("blocks");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool::rule>().speed)>("speed");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool::rule>().correct_drop_for_blocks)>("correct_drop_for_blocks");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::tool::rule& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks, "blocks");
  fn(obj.speed, "speed");
  fn(obj.correct_drop_for_blocks, "correct_drop_for_blocks");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::tool::rule& obj, [[maybe_unused]] FN&& fn){
  fn(obj.blocks, "blocks");
  fn(obj.speed, "speed");
  fn(obj.correct_drop_for_blocks, "correct_drop_for_blocks");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::tool::rule>() { return "copper_server::base_objects::component::tool::rule"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::tool::rule>() { return 3; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::tool& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rules);
  fn(obj.default_mine_speed);
  fn(obj.damage_per_block);
  fn(obj.creative_protection);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::tool& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rules);
  fn(obj.default_mine_speed);
  fn(obj.damage_per_block);
  fn(obj.creative_protection);
}
template<>struct for_each_type_s<copper_server::base_objects::component::tool> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().rules)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().default_mine_speed)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().damage_per_block)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().creative_protection)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::tool> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().rules)>("rules");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().default_mine_speed)>("default_mine_speed");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().damage_per_block)>("damage_per_block");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tool>().creative_protection)>("creative_protection");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::tool& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rules, "rules");
  fn(obj.default_mine_speed, "default_mine_speed");
  fn(obj.damage_per_block, "damage_per_block");
  fn(obj.creative_protection, "creative_protection");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::tool& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rules, "rules");
  fn(obj.default_mine_speed, "default_mine_speed");
  fn(obj.damage_per_block, "damage_per_block");
  fn(obj.creative_protection, "creative_protection");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::tool>() { return "copper_server::base_objects::component::tool"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::tool>() { return 4; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::weapon& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg_per_attack);
  fn(obj.disable_shield_for);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::weapon& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg_per_attack);
  fn(obj.disable_shield_for);
}
template<>struct for_each_type_s<copper_server::base_objects::component::weapon> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::weapon>().dmg_per_attack)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::weapon>().disable_shield_for)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::weapon> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::weapon>().dmg_per_attack)>("dmg_per_attack");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::weapon>().disable_shield_for)>("disable_shield_for");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::weapon& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg_per_attack, "dmg_per_attack");
  fn(obj.disable_shield_for, "disable_shield_for");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::weapon& obj, [[maybe_unused]] FN&& fn){
  fn(obj.dmg_per_attack, "dmg_per_attack");
  fn(obj.disable_shield_for, "disable_shield_for");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::weapon>() { return "copper_server::base_objects::component::weapon"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::weapon>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::enchantable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::enchantable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::enchantable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantable>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::enchantable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::enchantable>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::enchantable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::enchantable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::enchantable>() { return "copper_server::base_objects::component::enchantable"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::enchantable>() { return 1; }
template<>struct enum_data<copper_server::base_objects::component::equippable::equippable_on_e> {using item = std::pair<std::string_view, copper_server::base_objects::component::equippable::equippable_on_e>;
static constexpr inline std::array<item, 7> values = {item{"main_hand", copper_server::base_objects::component::equippable::equippable_on_e::main_hand}, item{"feet", copper_server::base_objects::component::equippable::equippable_on_e::feet}, item{"legs", copper_server::base_objects::component::equippable::equippable_on_e::legs}, item{"chest", copper_server::base_objects::component::equippable::equippable_on_e::chest}, item{"head", copper_server::base_objects::component::equippable::equippable_on_e::head}, item{"off_hand", copper_server::base_objects::component::equippable::equippable_on_e::off_hand}, item{"body", copper_server::base_objects::component::equippable::equippable_on_e::body}};};
template<>consteval std::string_view type_name<copper_server::base_objects::component::equippable::equippable_on_e>() { return "copper_server::base_objects::component::equippable::equippable_on_e"; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::equippable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.equippable_on);
  fn(obj.equip_sound);
  fn(obj.model);
  fn(obj.overlay);
  fn(obj.allowed_entities);
  fn(obj.dispensable);
  fn(obj.swappable);
  fn(obj.reduces_durability_on_damage);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::equippable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.equippable_on);
  fn(obj.equip_sound);
  fn(obj.model);
  fn(obj.overlay);
  fn(obj.allowed_entities);
  fn(obj.dispensable);
  fn(obj.swappable);
  fn(obj.reduces_durability_on_damage);
}
template<>struct for_each_type_s<copper_server::base_objects::component::equippable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().equippable_on)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().equip_sound)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().model)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().overlay)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().allowed_entities)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().dispensable)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().swappable)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().reduces_durability_on_damage)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::equippable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().equippable_on)>("equippable_on");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().equip_sound)>("equip_sound");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().model)>("model");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().overlay)>("overlay");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().allowed_entities)>("allowed_entities");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().dispensable)>("dispensable");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().swappable)>("swappable");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::equippable>().reduces_durability_on_damage)>("reduces_durability_on_damage");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::equippable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.equippable_on, "equippable_on");
  fn(obj.equip_sound, "equip_sound");
  fn(obj.model, "model");
  fn(obj.overlay, "overlay");
  fn(obj.allowed_entities, "allowed_entities");
  fn(obj.dispensable, "dispensable");
  fn(obj.swappable, "swappable");
  fn(obj.reduces_durability_on_damage, "reduces_durability_on_damage");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::equippable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.equippable_on, "equippable_on");
  fn(obj.equip_sound, "equip_sound");
  fn(obj.model, "model");
  fn(obj.overlay, "overlay");
  fn(obj.allowed_entities, "allowed_entities");
  fn(obj.dispensable, "dispensable");
  fn(obj.swappable, "swappable");
  fn(obj.reduces_durability_on_damage, "reduces_durability_on_damage");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::equippable>() { return "copper_server::base_objects::component::equippable"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::equippable>() { return 8; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::repairable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::repairable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items);
}
template<>struct for_each_type_s<copper_server::base_objects::component::repairable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::repairable>().items)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::repairable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::repairable>().items)>("items");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::repairable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items, "items");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::repairable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items, "items");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::repairable>() { return "copper_server::base_objects::component::repairable"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::repairable>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::glider& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::glider& obj, [[maybe_unused]] FN&& fn){
}
template<>struct for_each_type_s<copper_server::base_objects::component::glider> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::glider> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::glider& obj, [[maybe_unused]] FN&& fn){
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::glider& obj, [[maybe_unused]] FN&& fn){
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::glider>() { return "copper_server::base_objects::component::glider"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::glider>() { return 0; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::tooltip_style& obj, [[maybe_unused]] FN&& fn){
  fn(obj.style);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::tooltip_style& obj, [[maybe_unused]] FN&& fn){
  fn(obj.style);
}
template<>struct for_each_type_s<copper_server::base_objects::component::tooltip_style> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tooltip_style>().style)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::tooltip_style> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tooltip_style>().style)>("style");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::tooltip_style& obj, [[maybe_unused]] FN&& fn){
  fn(obj.style, "style");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::tooltip_style& obj, [[maybe_unused]] FN&& fn){
  fn(obj.style, "style");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::tooltip_style>() { return "copper_server::base_objects::component::tooltip_style"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::tooltip_style>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::death_protection& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::death_protection& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
}
template<>struct for_each_type_s<copper_server::base_objects::component::death_protection> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::death_protection>().effects)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::death_protection> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::death_protection>().effects)>("effects");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::death_protection& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::death_protection& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::death_protection>() { return "copper_server::base_objects::component::death_protection"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::death_protection>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::blocks_attacks::damage_reductions& obj, [[maybe_unused]] FN&& fn){
  fn(obj.horizontal_block_angle);
  fn(obj.damage_kind);
  fn(obj.base);
  fn(obj.factor);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::blocks_attacks::damage_reductions& obj, [[maybe_unused]] FN&& fn){
  fn(obj.horizontal_block_angle);
  fn(obj.damage_kind);
  fn(obj.base);
  fn(obj.factor);
}
template<>struct for_each_type_s<copper_server::base_objects::component::blocks_attacks::damage_reductions> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().horizontal_block_angle)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().damage_kind)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().base)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().factor)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::blocks_attacks::damage_reductions> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().horizontal_block_angle)>("horizontal_block_angle");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().damage_kind)>("damage_kind");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().base)>("base");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks::damage_reductions>().factor)>("factor");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::blocks_attacks::damage_reductions& obj, [[maybe_unused]] FN&& fn){
  fn(obj.horizontal_block_angle, "horizontal_block_angle");
  fn(obj.damage_kind, "damage_kind");
  fn(obj.base, "base");
  fn(obj.factor, "factor");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::blocks_attacks::damage_reductions& obj, [[maybe_unused]] FN&& fn){
  fn(obj.horizontal_block_angle, "horizontal_block_angle");
  fn(obj.damage_kind, "damage_kind");
  fn(obj.base, "base");
  fn(obj.factor, "factor");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::blocks_attacks::damage_reductions>() { return "copper_server::base_objects::component::blocks_attacks::damage_reductions"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::blocks_attacks::damage_reductions>() { return 4; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::blocks_attacks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.block_delay);
  fn(obj.disable_cooldown_scale);
  fn(obj.reductions);
  fn(obj.item_damage_threshold);
  fn(obj.item_damage_base);
  fn(obj.item_damage_factor);
  fn(obj.bypassed_by);
  fn(obj.block_sound);
  fn(obj.disable_sound);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::blocks_attacks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.block_delay);
  fn(obj.disable_cooldown_scale);
  fn(obj.reductions);
  fn(obj.item_damage_threshold);
  fn(obj.item_damage_base);
  fn(obj.item_damage_factor);
  fn(obj.bypassed_by);
  fn(obj.block_sound);
  fn(obj.disable_sound);
}
template<>struct for_each_type_s<copper_server::base_objects::component::blocks_attacks> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().block_delay)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().disable_cooldown_scale)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().reductions)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().item_damage_threshold)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().item_damage_base)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().item_damage_factor)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().bypassed_by)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().block_sound)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().disable_sound)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::blocks_attacks> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().block_delay)>("block_delay");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().disable_cooldown_scale)>("disable_cooldown_scale");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().reductions)>("reductions");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().item_damage_threshold)>("item_damage_threshold");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().item_damage_base)>("item_damage_base");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().item_damage_factor)>("item_damage_factor");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().bypassed_by)>("bypassed_by");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().block_sound)>("block_sound");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::blocks_attacks>().disable_sound)>("disable_sound");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::blocks_attacks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.block_delay, "block_delay");
  fn(obj.disable_cooldown_scale, "disable_cooldown_scale");
  fn(obj.reductions, "reductions");
  fn(obj.item_damage_threshold, "item_damage_threshold");
  fn(obj.item_damage_base, "item_damage_base");
  fn(obj.item_damage_factor, "item_damage_factor");
  fn(obj.bypassed_by, "bypassed_by");
  fn(obj.block_sound, "block_sound");
  fn(obj.disable_sound, "disable_sound");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::blocks_attacks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.block_delay, "block_delay");
  fn(obj.disable_cooldown_scale, "disable_cooldown_scale");
  fn(obj.reductions, "reductions");
  fn(obj.item_damage_threshold, "item_damage_threshold");
  fn(obj.item_damage_base, "item_damage_base");
  fn(obj.item_damage_factor, "item_damage_factor");
  fn(obj.bypassed_by, "bypassed_by");
  fn(obj.block_sound, "block_sound");
  fn(obj.disable_sound, "disable_sound");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::blocks_attacks>() { return "copper_server::base_objects::component::blocks_attacks"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::blocks_attacks>() { return 9; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::stored_enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
  fn(obj.level);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::stored_enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
  fn(obj.level);
}
template<>struct for_each_type_s<copper_server::base_objects::component::stored_enchantments::enchantment> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::stored_enchantments::enchantment>().id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::stored_enchantments::enchantment>().level)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::stored_enchantments::enchantment> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::stored_enchantments::enchantment>().id)>("id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::stored_enchantments::enchantment>().level)>("level");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::stored_enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
  fn(obj.level, "level");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::stored_enchantments::enchantment& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
  fn(obj.level, "level");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::stored_enchantments::enchantment>() { return "copper_server::base_objects::component::stored_enchantments::enchantment"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::stored_enchantments::enchantment>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::stored_enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::stored_enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments);
}
template<>struct for_each_type_s<copper_server::base_objects::component::stored_enchantments> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::stored_enchantments>().enchantments)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::stored_enchantments> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::stored_enchantments>().enchantments)>("enchantments");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::stored_enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments, "enchantments");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::stored_enchantments& obj, [[maybe_unused]] FN&& fn){
  fn(obj.enchantments, "enchantments");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::stored_enchantments>() { return "copper_server::base_objects::component::stored_enchantments"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::stored_enchantments>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::dyed_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::dyed_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb);
}
template<>struct for_each_type_s<copper_server::base_objects::component::dyed_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::dyed_color>().rgb)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::dyed_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::dyed_color>().rgb)>("rgb");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::dyed_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb, "rgb");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::dyed_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb, "rgb");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::dyed_color>() { return "copper_server::base_objects::component::dyed_color"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::dyed_color>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::map_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::map_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb);
}
template<>struct for_each_type_s<copper_server::base_objects::component::map_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_color>().rgb)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::map_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_color>().rgb)>("rgb");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::map_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb, "rgb");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::map_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.rgb, "rgb");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::map_color>() { return "copper_server::base_objects::component::map_color"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::map_color>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::map_id& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::map_id& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
}
template<>struct for_each_type_s<copper_server::base_objects::component::map_id> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_id>().id)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::map_id> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_id>().id)>("id");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::map_id& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::map_id& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::map_id>() { return "copper_server::base_objects::component::map_id"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::map_id>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::map_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::map_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::map_decorations> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_decorations>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::map_decorations> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_decorations>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::map_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::map_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::map_decorations>() { return "copper_server::base_objects::component::map_decorations"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::map_decorations>() { return 1; }
template<>struct enum_data<copper_server::base_objects::component::map_post_processing::type_e> {using item = std::pair<std::string_view, copper_server::base_objects::component::map_post_processing::type_e>;
static constexpr inline std::array<item, 2> values = {item{"lock", copper_server::base_objects::component::map_post_processing::type_e::lock}, item{"scale", copper_server::base_objects::component::map_post_processing::type_e::scale}};};
template<>consteval std::string_view type_name<copper_server::base_objects::component::map_post_processing::type_e>() { return "copper_server::base_objects::component::map_post_processing::type_e"; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::map_post_processing& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::map_post_processing& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type);
}
template<>struct for_each_type_s<copper_server::base_objects::component::map_post_processing> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_post_processing>().type)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::map_post_processing> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::map_post_processing>().type)>("type");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::map_post_processing& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type, "type");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::map_post_processing& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type, "type");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::map_post_processing>() { return "copper_server::base_objects::component::map_post_processing"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::map_post_processing>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::charged_projectiles& obj, [[maybe_unused]] FN&& fn){
  fn(obj.projectiles);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::charged_projectiles& obj, [[maybe_unused]] FN&& fn){
  fn(obj.projectiles);
}
template<>struct for_each_type_s<copper_server::base_objects::component::charged_projectiles> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::charged_projectiles>().projectiles)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::charged_projectiles> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::charged_projectiles>().projectiles)>("projectiles");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::charged_projectiles& obj, [[maybe_unused]] FN&& fn){
  fn(obj.projectiles, "projectiles");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::charged_projectiles& obj, [[maybe_unused]] FN&& fn){
  fn(obj.projectiles, "projectiles");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::charged_projectiles>() { return "copper_server::base_objects::component::charged_projectiles"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::charged_projectiles>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::bundle_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.content);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::bundle_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.content);
}
template<>struct for_each_type_s<copper_server::base_objects::component::bundle_contents> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bundle_contents>().content)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::bundle_contents> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bundle_contents>().content)>("content");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::bundle_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.content, "content");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::bundle_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.content, "content");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::bundle_contents>() { return "copper_server::base_objects::component::bundle_contents"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::bundle_contents>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::potion_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
  fn(obj.custom_color);
  fn(obj.custom_effects);
  fn(obj.custom_name);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::potion_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
  fn(obj.custom_color);
  fn(obj.custom_effects);
  fn(obj.custom_name);
}
template<>struct for_each_type_s<copper_server::base_objects::component::potion_contents> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().custom_color)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().custom_effects)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().custom_name)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::potion_contents> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().id)>("id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().custom_color)>("custom_color");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().custom_effects)>("custom_effects");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_contents>().custom_name)>("custom_name");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::potion_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
  fn(obj.custom_color, "custom_color");
  fn(obj.custom_effects, "custom_effects");
  fn(obj.custom_name, "custom_name");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::potion_contents& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
  fn(obj.custom_color, "custom_color");
  fn(obj.custom_effects, "custom_effects");
  fn(obj.custom_name, "custom_name");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::potion_contents>() { return "copper_server::base_objects::component::potion_contents"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::potion_contents>() { return 4; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::potion_duration_scale& obj, [[maybe_unused]] FN&& fn){
  fn(obj.multiplier);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::potion_duration_scale& obj, [[maybe_unused]] FN&& fn){
  fn(obj.multiplier);
}
template<>struct for_each_type_s<copper_server::base_objects::component::potion_duration_scale> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_duration_scale>().multiplier)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::potion_duration_scale> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::potion_duration_scale>().multiplier)>("multiplier");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::potion_duration_scale& obj, [[maybe_unused]] FN&& fn){
  fn(obj.multiplier, "multiplier");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::potion_duration_scale& obj, [[maybe_unused]] FN&& fn){
  fn(obj.multiplier, "multiplier");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::potion_duration_scale>() { return "copper_server::base_objects::component::potion_duration_scale"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::potion_duration_scale>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::suspicious_stew_effects::effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.potion_id);
  fn(obj.duration);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::suspicious_stew_effects::effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.potion_id);
  fn(obj.duration);
}
template<>struct for_each_type_s<copper_server::base_objects::component::suspicious_stew_effects::effect> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::suspicious_stew_effects::effect>().potion_id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::suspicious_stew_effects::effect>().duration)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::suspicious_stew_effects::effect> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::suspicious_stew_effects::effect>().potion_id)>("potion_id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::suspicious_stew_effects::effect>().duration)>("duration");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::suspicious_stew_effects::effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.potion_id, "potion_id");
  fn(obj.duration, "duration");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::suspicious_stew_effects::effect& obj, [[maybe_unused]] FN&& fn){
  fn(obj.potion_id, "potion_id");
  fn(obj.duration, "duration");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::suspicious_stew_effects::effect>() { return "copper_server::base_objects::component::suspicious_stew_effects::effect"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::suspicious_stew_effects::effect>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::suspicious_stew_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::suspicious_stew_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects);
}
template<>struct for_each_type_s<copper_server::base_objects::component::suspicious_stew_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::suspicious_stew_effects>().effects)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::suspicious_stew_effects> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::suspicious_stew_effects>().effects)>("effects");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::suspicious_stew_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::suspicious_stew_effects& obj, [[maybe_unused]] FN&& fn){
  fn(obj.effects, "effects");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::suspicious_stew_effects>() { return "copper_server::base_objects::component::suspicious_stew_effects"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::suspicious_stew_effects>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::writable_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw);
  fn(obj.filtered);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::writable_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw);
  fn(obj.filtered);
}
template<>struct for_each_type_s<copper_server::base_objects::component::writable_book_content::page> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::writable_book_content::page>().raw)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::writable_book_content::page>().filtered)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::writable_book_content::page> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::writable_book_content::page>().raw)>("raw");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::writable_book_content::page>().filtered)>("filtered");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::writable_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw, "raw");
  fn(obj.filtered, "filtered");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::writable_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw, "raw");
  fn(obj.filtered, "filtered");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::writable_book_content::page>() { return "copper_server::base_objects::component::writable_book_content::page"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::writable_book_content::page>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::writable_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pages);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::writable_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pages);
}
template<>struct for_each_type_s<copper_server::base_objects::component::writable_book_content> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::writable_book_content>().pages)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::writable_book_content> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::writable_book_content>().pages)>("pages");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::writable_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pages, "pages");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::writable_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pages, "pages");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::writable_book_content>() { return "copper_server::base_objects::component::writable_book_content"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::writable_book_content>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::written_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw);
  fn(obj.filtered);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::written_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw);
  fn(obj.filtered);
}
template<>struct for_each_type_s<copper_server::base_objects::component::written_book_content::page> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content::page>().raw)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content::page>().filtered)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::written_book_content::page> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content::page>().raw)>("raw");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content::page>().filtered)>("filtered");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::written_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw, "raw");
  fn(obj.filtered, "filtered");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::written_book_content::page& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw, "raw");
  fn(obj.filtered, "filtered");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::written_book_content::page>() { return "copper_server::base_objects::component::written_book_content::page"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::written_book_content::page>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::written_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw_title);
  fn(obj.filtered_title);
  fn(obj.author);
  fn(obj.generation);
  fn(obj.pages);
  fn(obj.resolved);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::written_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw_title);
  fn(obj.filtered_title);
  fn(obj.author);
  fn(obj.generation);
  fn(obj.pages);
  fn(obj.resolved);
}
template<>struct for_each_type_s<copper_server::base_objects::component::written_book_content> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().raw_title)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().filtered_title)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().author)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().generation)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().pages)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().resolved)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::written_book_content> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().raw_title)>("raw_title");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().filtered_title)>("filtered_title");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().author)>("author");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().generation)>("generation");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().pages)>("pages");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::written_book_content>().resolved)>("resolved");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::written_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw_title, "raw_title");
  fn(obj.filtered_title, "filtered_title");
  fn(obj.author, "author");
  fn(obj.generation, "generation");
  fn(obj.pages, "pages");
  fn(obj.resolved, "resolved");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::written_book_content& obj, [[maybe_unused]] FN&& fn){
  fn(obj.raw_title, "raw_title");
  fn(obj.filtered_title, "filtered_title");
  fn(obj.author, "author");
  fn(obj.generation, "generation");
  fn(obj.pages, "pages");
  fn(obj.resolved, "resolved");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::written_book_content>() { return "copper_server::base_objects::component::written_book_content"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::written_book_content>() { return 6; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::trim& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material);
  fn(obj.pattern);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::trim& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material);
  fn(obj.pattern);
}
template<>struct for_each_type_s<copper_server::base_objects::component::trim> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::trim>().material)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::trim>().pattern)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::trim> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::trim>().material)>("material");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::trim>().pattern)>("pattern");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::trim& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material, "material");
  fn(obj.pattern, "pattern");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::trim& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material, "material");
  fn(obj.pattern, "pattern");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::trim>() { return "copper_server::base_objects::component::trim"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::trim>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::debug_stick_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::debug_stick_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<>struct for_each_type_s<copper_server::base_objects::component::debug_stick_state> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::debug_stick_state>().data)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::debug_stick_state> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::debug_stick_state>().data)>("data");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::debug_stick_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::debug_stick_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::debug_stick_state>() { return "copper_server::base_objects::component::debug_stick_state"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::debug_stick_state>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<>struct for_each_type_s<copper_server::base_objects::component::entity_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::entity_data>().data)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::entity_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::entity_data>().data)>("data");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::entity_data>() { return "copper_server::base_objects::component::entity_data"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::entity_data>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::bucket_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::bucket_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<>struct for_each_type_s<copper_server::base_objects::component::bucket_entity_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bucket_entity_data>().data)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::bucket_entity_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bucket_entity_data>().data)>("data");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::bucket_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::bucket_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::bucket_entity_data>() { return "copper_server::base_objects::component::bucket_entity_data"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::bucket_entity_data>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::block_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::block_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<>struct for_each_type_s<copper_server::base_objects::component::block_entity_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_entity_data>().data)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::block_entity_data> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_entity_data>().data)>("data");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::block_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::block_entity_data& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::block_entity_data>() { return "copper_server::base_objects::component::block_entity_data"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::block_entity_data>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::instrument> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::instrument>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::instrument> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::instrument>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::instrument& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::instrument>() { return "copper_server::base_objects::component::instrument"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::instrument>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::provides_trim_material::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::provides_trim_material::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<>struct for_each_type_s<copper_server::base_objects::component::provides_trim_material::reference> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_trim_material::reference>().name)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::provides_trim_material::reference> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_trim_material::reference>().name)>("name");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::provides_trim_material::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::provides_trim_material::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::provides_trim_material::reference>() { return "copper_server::base_objects::component::provides_trim_material::reference"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::provides_trim_material::reference>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::provides_trim_material::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::provides_trim_material::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::provides_trim_material::direct> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_trim_material::direct>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::provides_trim_material::direct> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_trim_material::direct>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::provides_trim_material::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::provides_trim_material::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::provides_trim_material::direct>() { return "copper_server::base_objects::component::provides_trim_material::direct"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::provides_trim_material::direct>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::provides_trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::provides_trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material);
}
template<>struct for_each_type_s<copper_server::base_objects::component::provides_trim_material> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_trim_material>().material)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::provides_trim_material> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_trim_material>().material)>("material");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::provides_trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material, "material");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::provides_trim_material& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material, "material");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::provides_trim_material>() { return "copper_server::base_objects::component::provides_trim_material"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::provides_trim_material>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::ominous_bottle_amplifier& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::ominous_bottle_amplifier& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier);
}
template<>struct for_each_type_s<copper_server::base_objects::component::ominous_bottle_amplifier> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::ominous_bottle_amplifier>().amplifier)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::ominous_bottle_amplifier> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::ominous_bottle_amplifier>().amplifier)>("amplifier");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::ominous_bottle_amplifier& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier, "amplifier");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::ominous_bottle_amplifier& obj, [[maybe_unused]] FN&& fn){
  fn(obj.amplifier, "amplifier");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::ominous_bottle_amplifier>() { return "copper_server::base_objects::component::ominous_bottle_amplifier"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::ominous_bottle_amplifier>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::jukebox_playable::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::jukebox_playable::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<>struct for_each_type_s<copper_server::base_objects::component::jukebox_playable::reference> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::jukebox_playable::reference>().name)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::jukebox_playable::reference> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::jukebox_playable::reference>().name)>("name");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::jukebox_playable::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::jukebox_playable::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::jukebox_playable::reference>() { return "copper_server::base_objects::component::jukebox_playable::reference"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::jukebox_playable::reference>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::jukebox_playable::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::jukebox_playable::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::jukebox_playable::direct> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::jukebox_playable::direct>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::jukebox_playable::direct> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::jukebox_playable::direct>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::jukebox_playable::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::jukebox_playable::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::jukebox_playable::direct>() { return "copper_server::base_objects::component::jukebox_playable::direct"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::jukebox_playable::direct>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::jukebox_playable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::jukebox_playable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material);
}
template<>struct for_each_type_s<copper_server::base_objects::component::jukebox_playable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::jukebox_playable>().material)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::jukebox_playable> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::jukebox_playable>().material)>("material");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::jukebox_playable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material, "material");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::jukebox_playable& obj, [[maybe_unused]] FN&& fn){
  fn(obj.material, "material");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::jukebox_playable>() { return "copper_server::base_objects::component::jukebox_playable"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::jukebox_playable>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::provides_banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::provides_banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key);
}
template<>struct for_each_type_s<copper_server::base_objects::component::provides_banner_patterns> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_banner_patterns>().key)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::provides_banner_patterns> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::provides_banner_patterns>().key)>("key");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::provides_banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key, "key");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::provides_banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key, "key");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::provides_banner_patterns>() { return "copper_server::base_objects::component::provides_banner_patterns"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::provides_banner_patterns>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::recipes& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::recipes& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data);
}
template<>struct for_each_type_s<copper_server::base_objects::component::recipes> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::recipes>().data)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::recipes> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::recipes>().data)>("data");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::recipes& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::recipes& obj, [[maybe_unused]] FN&& fn){
  fn(obj.data, "data");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::recipes>() { return "copper_server::base_objects::component::recipes"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::recipes>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::lodestone_tracker::position& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has_global_position);
  fn(obj.pos);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::lodestone_tracker::position& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has_global_position);
  fn(obj.pos);
}
template<>struct for_each_type_s<copper_server::base_objects::component::lodestone_tracker::position> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lodestone_tracker::position>().has_global_position)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lodestone_tracker::position>().pos)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::lodestone_tracker::position> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lodestone_tracker::position>().has_global_position)>("has_global_position");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lodestone_tracker::position>().pos)>("pos");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::lodestone_tracker::position& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has_global_position, "has_global_position");
  fn(obj.pos, "pos");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::lodestone_tracker::position& obj, [[maybe_unused]] FN&& fn){
  fn(obj.has_global_position, "has_global_position");
  fn(obj.pos, "pos");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::lodestone_tracker::position>() { return "copper_server::base_objects::component::lodestone_tracker::position"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::lodestone_tracker::position>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::lodestone_tracker& obj, [[maybe_unused]] FN&& fn){
  fn(obj.global_position);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::lodestone_tracker& obj, [[maybe_unused]] FN&& fn){
  fn(obj.global_position);
}
template<>struct for_each_type_s<copper_server::base_objects::component::lodestone_tracker> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lodestone_tracker>().global_position)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::lodestone_tracker> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lodestone_tracker>().global_position)>("global_position");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::lodestone_tracker& obj, [[maybe_unused]] FN&& fn){
  fn(obj.global_position, "global_position");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::lodestone_tracker& obj, [[maybe_unused]] FN&& fn){
  fn(obj.global_position, "global_position");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::lodestone_tracker>() { return "copper_server::base_objects::component::lodestone_tracker"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::lodestone_tracker>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.explosion);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.explosion);
}
template<>struct for_each_type_s<copper_server::base_objects::component::firework_explosion> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::firework_explosion>().explosion)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::firework_explosion> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::firework_explosion>().explosion)>("explosion");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.explosion, "explosion");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::firework_explosion& obj, [[maybe_unused]] FN&& fn){
  fn(obj.explosion, "explosion");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::firework_explosion>() { return "copper_server::base_objects::component::firework_explosion"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::firework_explosion>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::fireworks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.flight_duration);
  fn(obj.explosions);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::fireworks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.flight_duration);
  fn(obj.explosions);
}
template<>struct for_each_type_s<copper_server::base_objects::component::fireworks> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::fireworks>().flight_duration)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::fireworks>().explosions)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::fireworks> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::fireworks>().flight_duration)>("flight_duration");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::fireworks>().explosions)>("explosions");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::fireworks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.flight_duration, "flight_duration");
  fn(obj.explosions, "explosions");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::fireworks& obj, [[maybe_unused]] FN&& fn){
  fn(obj.flight_duration, "flight_duration");
  fn(obj.explosions, "explosions");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::fireworks>() { return "copper_server::base_objects::component::fireworks"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::fireworks>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::profile::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.value);
  fn(obj.signature);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::profile::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.value);
  fn(obj.signature);
}
template<>struct for_each_type_s<copper_server::base_objects::component::profile::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile::property>().name)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile::property>().value)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile::property>().signature)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::profile::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile::property>().name)>("name");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile::property>().value)>("value");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile::property>().signature)>("signature");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::profile::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.value, "value");
  fn(obj.signature, "signature");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::profile::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.value, "value");
  fn(obj.signature, "signature");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::profile::property>() { return "copper_server::base_objects::component::profile::property"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::profile::property>() { return 3; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::profile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.uuid);
  fn(obj.properties);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::profile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.uuid);
  fn(obj.properties);
}
template<>struct for_each_type_s<copper_server::base_objects::component::profile> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile>().name)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile>().uuid)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile>().properties)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::profile> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile>().name)>("name");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile>().uuid)>("uuid");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::profile>().properties)>("properties");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::profile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.uuid, "uuid");
  fn(obj.properties, "properties");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::profile& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.uuid, "uuid");
  fn(obj.properties, "properties");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::profile>() { return "copper_server::base_objects::component::profile"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::profile>() { return 3; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::note_block_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::note_block_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
}
template<>struct for_each_type_s<copper_server::base_objects::component::note_block_sound> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::note_block_sound>().sound)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::note_block_sound> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::note_block_sound>().sound)>("sound");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::note_block_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::note_block_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::note_block_sound>() { return "copper_server::base_objects::component::note_block_sound"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::note_block_sound>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::banner_patterns::layer::decl& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_id);
  fn(obj.translation_key);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::banner_patterns::layer::decl& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_id);
  fn(obj.translation_key);
}
template<>struct for_each_type_s<copper_server::base_objects::component::banner_patterns::layer::decl> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer::decl>().asset_id)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer::decl>().translation_key)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::banner_patterns::layer::decl> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer::decl>().asset_id)>("asset_id");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer::decl>().translation_key)>("translation_key");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::banner_patterns::layer::decl& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_id, "asset_id");
  fn(obj.translation_key, "translation_key");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::banner_patterns::layer::decl& obj, [[maybe_unused]] FN&& fn){
  fn(obj.asset_id, "asset_id");
  fn(obj.translation_key, "translation_key");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::banner_patterns::layer::decl>() { return "copper_server::base_objects::component::banner_patterns::layer::decl"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::banner_patterns::layer::decl>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::banner_patterns::layer& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pattern_type);
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::banner_patterns::layer& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pattern_type);
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::banner_patterns::layer> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer>().pattern_type)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::banner_patterns::layer> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer>().pattern_type)>("pattern_type");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns::layer>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::banner_patterns::layer& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pattern_type, "pattern_type");
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::banner_patterns::layer& obj, [[maybe_unused]] FN&& fn){
  fn(obj.pattern_type, "pattern_type");
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::banner_patterns::layer>() { return "copper_server::base_objects::component::banner_patterns::layer"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::banner_patterns::layer>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.layers);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.layers);
}
template<>struct for_each_type_s<copper_server::base_objects::component::banner_patterns> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns>().layers)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::banner_patterns> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::banner_patterns>().layers)>("layers");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.layers, "layers");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::banner_patterns& obj, [[maybe_unused]] FN&& fn){
  fn(obj.layers, "layers");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::banner_patterns>() { return "copper_server::base_objects::component::banner_patterns"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::banner_patterns>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::base_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::base_color>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::base_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::base_color>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::base_color>() { return "copper_server::base_objects::component::base_color"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::base_color>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::pot_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.item_decorations);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::pot_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.item_decorations);
}
template<>struct for_each_type_s<copper_server::base_objects::component::pot_decorations> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::pot_decorations>().item_decorations)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::pot_decorations> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::pot_decorations>().item_decorations)>("item_decorations");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::pot_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.item_decorations, "item_decorations");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::pot_decorations& obj, [[maybe_unused]] FN&& fn){
  fn(obj.item_decorations, "item_decorations");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::pot_decorations>() { return "copper_server::base_objects::component::pot_decorations"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::pot_decorations>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::container& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::container& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items);
}
template<>struct for_each_type_s<copper_server::base_objects::component::container> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::container>().items)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::container> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::container>().items)>("items");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::container& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items, "items");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::container& obj, [[maybe_unused]] FN&& fn){
  fn(obj.items, "items");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::container>() { return "copper_server::base_objects::component::container"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::container>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::block_state::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.value);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::block_state::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
  fn(obj.value);
}
template<>struct for_each_type_s<copper_server::base_objects::component::block_state::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_state::property>().name)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_state::property>().value)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::block_state::property> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_state::property>().name)>("name");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_state::property>().value)>("value");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::block_state::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.value, "value");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::block_state::property& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
  fn(obj.value, "value");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::block_state::property>() { return "copper_server::base_objects::component::block_state::property"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::block_state::property>() { return 2; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::block_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.properties);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::block_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.properties);
}
template<>struct for_each_type_s<copper_server::base_objects::component::block_state> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_state>().properties)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::block_state> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::block_state>().properties)>("properties");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::block_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.properties, "properties");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::block_state& obj, [[maybe_unused]] FN&& fn){
  fn(obj.properties, "properties");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::block_state>() { return "copper_server::base_objects::component::block_state"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::block_state>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::bees::bee& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nbt);
  fn(obj.ticks_in_hive);
  fn(obj.min_ticks_in_hive);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::bees::bee& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nbt);
  fn(obj.ticks_in_hive);
  fn(obj.min_ticks_in_hive);
}
template<>struct for_each_type_s<copper_server::base_objects::component::bees::bee> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees::bee>().nbt)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees::bee>().ticks_in_hive)>();
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees::bee>().min_ticks_in_hive)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::bees::bee> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees::bee>().nbt)>("nbt");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees::bee>().ticks_in_hive)>("ticks_in_hive");
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees::bee>().min_ticks_in_hive)>("min_ticks_in_hive");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::bees::bee& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nbt, "nbt");
  fn(obj.ticks_in_hive, "ticks_in_hive");
  fn(obj.min_ticks_in_hive, "min_ticks_in_hive");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::bees::bee& obj, [[maybe_unused]] FN&& fn){
  fn(obj.nbt, "nbt");
  fn(obj.ticks_in_hive, "ticks_in_hive");
  fn(obj.min_ticks_in_hive, "min_ticks_in_hive");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::bees::bee>() { return "copper_server::base_objects::component::bees::bee"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::bees::bee>() { return 3; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::bees& obj, [[maybe_unused]] FN&& fn){
  fn(obj.inside);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::bees& obj, [[maybe_unused]] FN&& fn){
  fn(obj.inside);
}
template<>struct for_each_type_s<copper_server::base_objects::component::bees> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees>().inside)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::bees> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::bees>().inside)>("inside");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::bees& obj, [[maybe_unused]] FN&& fn){
  fn(obj.inside, "inside");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::bees& obj, [[maybe_unused]] FN&& fn){
  fn(obj.inside, "inside");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::bees>() { return "copper_server::base_objects::component::bees"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::bees>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::lock& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::lock& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key);
}
template<>struct for_each_type_s<copper_server::base_objects::component::lock> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lock>().key)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::lock> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::lock>().key)>("key");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::lock& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key, "key");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::lock& obj, [[maybe_unused]] FN&& fn){
  fn(obj.key, "key");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::lock>() { return "copper_server::base_objects::component::lock"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::lock>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::container_loot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.loot);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::container_loot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.loot);
}
template<>struct for_each_type_s<copper_server::base_objects::component::container_loot> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::container_loot>().loot)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::container_loot> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::container_loot>().loot)>("loot");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::container_loot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.loot, "loot");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::container_loot& obj, [[maybe_unused]] FN&& fn){
  fn(obj.loot, "loot");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::container_loot>() { return "copper_server::base_objects::component::container_loot"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::container_loot>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::break_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::break_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound);
}
template<>struct for_each_type_s<copper_server::base_objects::component::break_sound> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::break_sound>().sound)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::break_sound> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::break_sound>().sound)>("sound");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::break_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::break_sound& obj, [[maybe_unused]] FN&& fn){
  fn(obj.sound, "sound");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::break_sound>() { return "copper_server::base_objects::component::break_sound"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::break_sound>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::villager_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::villager_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::villager_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::villager_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::villager_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::villager_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::villager_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::villager_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::villager_variant>() { return "copper_server::base_objects::component::villager_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::villager_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::wolf_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::wolf_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::wolf_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::wolf_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::wolf_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::wolf_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::wolf_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::wolf_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::wolf_variant>() { return "copper_server::base_objects::component::wolf_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::wolf_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::wolf_sound_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::wolf_sound_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::wolf_sound_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::wolf_sound_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::wolf_sound_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::wolf_sound_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::wolf_sound_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::wolf_sound_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::wolf_sound_variant>() { return "copper_server::base_objects::component::wolf_sound_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::wolf_sound_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::wolf_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::wolf_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::wolf_collar> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::wolf_collar>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::wolf_collar> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::wolf_collar>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::wolf_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::wolf_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::wolf_collar>() { return "copper_server::base_objects::component::wolf_collar"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::wolf_collar>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::fox_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::fox_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::fox_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::fox_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::fox_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::fox_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::fox_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::fox_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::fox_variant>() { return "copper_server::base_objects::component::fox_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::fox_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::salmon_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::salmon_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size);
}
template<>struct for_each_type_s<copper_server::base_objects::component::salmon_size> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::salmon_size>().size)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::salmon_size> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::salmon_size>().size)>("size");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::salmon_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size, "size");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::salmon_size& obj, [[maybe_unused]] FN&& fn){
  fn(obj.size, "size");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::salmon_size>() { return "copper_server::base_objects::component::salmon_size"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::salmon_size>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::parrot_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::parrot_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::parrot_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::parrot_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::parrot_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::parrot_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::parrot_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::parrot_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::parrot_variant>() { return "copper_server::base_objects::component::parrot_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::parrot_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::tropical_fish_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::tropical_fish_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::tropical_fish_pattern> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tropical_fish_pattern>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::tropical_fish_pattern> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tropical_fish_pattern>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::tropical_fish_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::tropical_fish_pattern& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::tropical_fish_pattern>() { return "copper_server::base_objects::component::tropical_fish_pattern"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::tropical_fish_pattern>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::tropical_fish_base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::tropical_fish_base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::tropical_fish_base_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tropical_fish_base_color>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::tropical_fish_base_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tropical_fish_base_color>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::tropical_fish_base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::tropical_fish_base_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::tropical_fish_base_color>() { return "copper_server::base_objects::component::tropical_fish_base_color"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::tropical_fish_base_color>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::tropical_fish_pattern_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::tropical_fish_pattern_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::tropical_fish_pattern_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tropical_fish_pattern_color>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::tropical_fish_pattern_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::tropical_fish_pattern_color>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::tropical_fish_pattern_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::tropical_fish_pattern_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::tropical_fish_pattern_color>() { return "copper_server::base_objects::component::tropical_fish_pattern_color"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::tropical_fish_pattern_color>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::mooshroom_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::mooshroom_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::mooshroom_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::mooshroom_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::mooshroom_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::mooshroom_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::mooshroom_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::mooshroom_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::mooshroom_variant>() { return "copper_server::base_objects::component::mooshroom_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::mooshroom_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::rabbit_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::rabbit_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::rabbit_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::rabbit_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::rabbit_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::rabbit_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::rabbit_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::rabbit_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::rabbit_variant>() { return "copper_server::base_objects::component::rabbit_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::rabbit_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::pig_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::pig_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::pig_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::pig_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::pig_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::pig_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::pig_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::pig_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::pig_variant>() { return "copper_server::base_objects::component::pig_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::pig_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::cow_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::cow_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::cow_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::cow_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::cow_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::cow_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::cow_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::cow_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::cow_variant>() { return "copper_server::base_objects::component::cow_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::cow_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::chicken_variant::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::chicken_variant::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name);
}
template<>struct for_each_type_s<copper_server::base_objects::component::chicken_variant::reference> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::chicken_variant::reference>().name)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::chicken_variant::reference> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::chicken_variant::reference>().name)>("name");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::chicken_variant::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::chicken_variant::reference& obj, [[maybe_unused]] FN&& fn){
  fn(obj.name, "name");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::chicken_variant::reference>() { return "copper_server::base_objects::component::chicken_variant::reference"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::chicken_variant::reference>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::chicken_variant::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::chicken_variant::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id);
}
template<>struct for_each_type_s<copper_server::base_objects::component::chicken_variant::direct> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::chicken_variant::direct>().id)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::chicken_variant::direct> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::chicken_variant::direct>().id)>("id");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::chicken_variant::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::chicken_variant::direct& obj, [[maybe_unused]] FN&& fn){
  fn(obj.id, "id");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::chicken_variant::direct>() { return "copper_server::base_objects::component::chicken_variant::direct"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::chicken_variant::direct>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::chicken_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::chicken_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::chicken_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::chicken_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::chicken_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::chicken_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::chicken_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::chicken_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::chicken_variant>() { return "copper_server::base_objects::component::chicken_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::chicken_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::frog_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::frog_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::frog_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::frog_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::frog_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::frog_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::frog_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::frog_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::frog_variant>() { return "copper_server::base_objects::component::frog_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::frog_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::horse_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::horse_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::horse_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::horse_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::horse_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::horse_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::horse_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::horse_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::horse_variant>() { return "copper_server::base_objects::component::horse_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::horse_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::painting_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::painting_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::painting_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::painting_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::painting_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::painting_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::painting_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::painting_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::painting_variant>() { return "copper_server::base_objects::component::painting_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::painting_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::llama_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::llama_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::llama_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::llama_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::llama_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::llama_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::llama_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::llama_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::llama_variant>() { return "copper_server::base_objects::component::llama_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::llama_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::axolotl_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::axolotl_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::axolotl_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::axolotl_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::axolotl_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::axolotl_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::axolotl_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::axolotl_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::axolotl_variant>() { return "copper_server::base_objects::component::axolotl_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::axolotl_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::cat_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::cat_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant);
}
template<>struct for_each_type_s<copper_server::base_objects::component::cat_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::cat_variant>().variant)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::cat_variant> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::cat_variant>().variant)>("variant");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::cat_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::cat_variant& obj, [[maybe_unused]] FN&& fn){
  fn(obj.variant, "variant");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::cat_variant>() { return "copper_server::base_objects::component::cat_variant"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::cat_variant>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::cat_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::cat_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::cat_collar> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::cat_collar>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::cat_collar> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::cat_collar>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::cat_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::cat_collar& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::cat_collar>() { return "copper_server::base_objects::component::cat_collar"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::cat_collar>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::sheep_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::sheep_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::sheep_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::sheep_color>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::sheep_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::sheep_color>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::sheep_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::sheep_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::sheep_color>() { return "copper_server::base_objects::component::sheep_color"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::sheep_color>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component::shulker_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component::shulker_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color);
}
template<>struct for_each_type_s<copper_server::base_objects::component::shulker_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::shulker_color>().color)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component::shulker_color> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component::shulker_color>().color)>("color");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component::shulker_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component::shulker_color& obj, [[maybe_unused]] FN&& fn){
  fn(obj.color, "color");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component::shulker_color>() { return "copper_server::base_objects::component::shulker_color"; }
template<>consteval size_t fields_count<copper_server::base_objects::component::shulker_color>() { return 1; }
template<class FN>constexpr void for_each_field([[maybe_unused]] copper_server::base_objects::component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type);
}
template<class FN>constexpr void for_each_field([[maybe_unused]] const copper_server::base_objects::component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type);
}
template<>struct for_each_type_s<copper_server::base_objects::component> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component>().type)>();
}
};
template<>struct for_each_type_with_name_s<copper_server::base_objects::component> {
template<class FN>static constexpr void each([[maybe_unused]] FN&& fn){
  fn.template operator()<decltype(std::declval<copper_server::base_objects::component>().type)>("type");
}
};
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] copper_server::base_objects::component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type, "type");
}
template<class FN>constexpr void for_each_field_with_name([[maybe_unused]] const copper_server::base_objects::component& obj, [[maybe_unused]] FN&& fn){
  fn(obj.type, "type");
}
template<>consteval std::string_view type_name<copper_server::base_objects::component>() { return "copper_server::base_objects::component"; }
template<>consteval size_t fields_count<copper_server::base_objects::component>() { return 1; }
}
